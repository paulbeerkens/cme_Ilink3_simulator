//File generated by CodeGenerator
//Generated from: /home/pbeerkens/source/cme_Ilink3_simulator/data/Cme.Futures.iLink3.Sbe.v8.5.xml

#ifndef CMESIMULATOR_ILINK3_MSGS_GEN_H
#define CMESIMULATOR_ILINK3_MSGS_GEN_H
#include <cstdint>
#include <array>
#include "ILink3EnumsGen.h"
#include <ILINK3Messages/MessageBuffer.h>
#include <ILINK3Messages/Generated/ILink3Composite.h>

namespace IL3Msg {

class NegotiateMsg {
public:
	inline static const std::size_t id{500};

	//Contains the HMAC signature.
	[[nodiscard]] std::string_view getHMACSignature () const { return std::string_view(&blockData_->HMACSignature[0], 32);}

	//Contains the AccessKeyID assigned to this session on this port.
	[[nodiscard]] std::string_view getAccessKeyID () const { return std::string_view(&blockData_->AccessKeyID[0], 20);}

	//Session Identifier defined as type long (uInt64); recommended to use timestamp as number of microseconds since epoch (Jan 1, 1970)
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Session ID
	[[nodiscard]] std::string_view getSession () const { return std::string_view(&blockData_->Session[0], 3);}

	//Firm ID
	[[nodiscard]] std::string_view getFirm () const { return std::string_view(&blockData_->Firm[0], 5);}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::array<char, 32> HMACSignature;
		std::array<char, 20> AccessKeyID;
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::array<char, 3> Session;
		std::array<char, 5> Firm;
	};

	const BlockData *blockData_{nullptr};

	IL3Composite::Data data_;
};


class NegotiateMsgOut: public NegotiateMsg {
public:
	inline static const std::size_t blockLength {76};
	//static_assert (NegotiateMsgOut::blockLength==sizeof (NegotiateMsgOut::BlockData));

	NegotiateMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Contains the HMAC signature.
	void setHMACSignature (std::string_view v) { (void) v;}

	//Contains the AccessKeyID assigned to this session on this port.
	void setAccessKeyID (std::string_view v) { (void) v;}

	//Session Identifier defined as type long (uInt64); recommended to use timestamp as number of microseconds since epoch (Jan 1, 1970)
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Session ID
	void setSession (std::string_view v) { (void) v;}

	//Firm ID
	void setFirm (std::string_view v) { (void) v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class NegotiationResponseMsg {
public:
	inline static const std::size_t id{501};

	//Matches Negotiate.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Matches Negotiate.RequestTimestamp
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//This indicates in how many days the HMAC secret key will expire
	[[nodiscard]] std::uint16_t getSecretKeySecureIDExpiration () const { return blockData_->SecretKeySecureIDExpiration;}

	//Indicates whether the connection is primary or backup
	[[nodiscard]] IL3Enum::FTI getFaultToleranceIndicator () const { return blockData_->FaultToleranceIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Refers to the SeqNum sent in the previous message before this one from CME
	[[nodiscard]] std::uint32_t getPreviousSeqNo () const { return blockData_->PreviousSeqNo;}

	//Refers to the UUID sent in the previous message before this one from CME
	[[nodiscard]] std::uint64_t getPreviousUUID () const { return blockData_->PreviousUUID;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::uint16_t SecretKeySecureIDExpiration {65535UL};
		IL3Enum::FTI FaultToleranceIndicator {IL3Enum::FTI::Null};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		std::uint32_t PreviousSeqNo;
		std::uint64_t PreviousUUID;
	};

	const BlockData *blockData_{nullptr};

	IL3Composite::Data data_;
};


class NegotiationResponseMsgOut: public NegotiationResponseMsg {
public:
	inline static const std::size_t blockLength {32};
	//static_assert (NegotiationResponseMsgOut::blockLength==sizeof (NegotiationResponseMsgOut::BlockData));

	NegotiationResponseMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Matches Negotiate.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Matches Negotiate.RequestTimestamp
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//This indicates in how many days the HMAC secret key will expire
	void setSecretKeySecureIDExpiration (std::uint16_t v) { blockDataWrite_.SecretKeySecureIDExpiration=v;}

	//Indicates whether the connection is primary or backup
	void setFaultToleranceIndicator (IL3Enum::FTI v) { blockDataWrite_.FaultToleranceIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Refers to the SeqNum sent in the previous message before this one from CME
	void setPreviousSeqNo (std::uint32_t v) { blockDataWrite_.PreviousSeqNo=v;}

	//Refers to the UUID sent in the previous message before this one from CME
	void setPreviousUUID (std::uint64_t v) { blockDataWrite_.PreviousUUID=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class NegotiationRejectMsg {
public:
	inline static const std::size_t id{502};

	//Reject reason details
	[[nodiscard]] std::string_view getReason () const { return std::string_view(&blockData_->Reason[0], 48);}

	//Matches Negotiate.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Matches Negotiate.RequestTimestamp
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Error code for reject reason
	[[nodiscard]] std::uint16_t getErrorCodes () const { return blockData_->ErrorCodes;}

	//Indicates whether the connection is primary or backup
	[[nodiscard]] IL3Enum::FTI getFaultToleranceIndicator () const { return blockData_->FaultToleranceIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::array<char, 48> Reason;
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::uint16_t ErrorCodes;
		IL3Enum::FTI FaultToleranceIndicator {IL3Enum::FTI::Null};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class NegotiationRejectMsgOut: public NegotiationRejectMsg {
public:
	inline static const std::size_t blockLength {68};
	//static_assert (NegotiationRejectMsgOut::blockLength==sizeof (NegotiationRejectMsgOut::BlockData));

	NegotiationRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Reject reason details
	void setReason (std::string_view v) { (void) v;}

	//Matches Negotiate.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Matches Negotiate.RequestTimestamp
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Error code for reject reason
	void setErrorCodes (std::uint16_t v) { blockDataWrite_.ErrorCodes=v;}

	//Indicates whether the connection is primary or backup
	void setFaultToleranceIndicator (IL3Enum::FTI v) { blockDataWrite_.FaultToleranceIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class EstablishMsg {
public:
	inline static const std::size_t id{503};

	//Contains the HMAC signature
	[[nodiscard]] std::string_view getHMACSignature () const { return std::string_view(&blockData_->HMACSignature[0], 32);}

	//Contains the AccessKeyID assigned to this session on this port
	[[nodiscard]] std::string_view getAccessKeyID () const { return std::string_view(&blockData_->AccessKeyID[0], 20);}

	//Provides the name of the application system being used to generate FIX application messages.
	[[nodiscard]] std::string_view getTradingSystemName () const { return std::string_view(&blockData_->TradingSystemName[0], 30);}

	//Provides the version of the application system being used to initiate FIX application messages.
	[[nodiscard]] std::string_view getTradingSystemVersion () const { return std::string_view(&blockData_->TradingSystemVersion[0], 10);}

	//Provides the vendor of the application system
	[[nodiscard]] std::string_view getTradingSystemVendor () const { return std::string_view(&blockData_->TradingSystemVendor[0], 10);}

	//Session Identifier defined as type long (uInt64); recommended to use timestamp as number of microseconds since epoch (Jan 1, 1970)
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Next expected message sequence number
	[[nodiscard]] std::uint32_t getNextSeqNo () const { return blockData_->NextSeqNo;}

	//Session ID
	[[nodiscard]] std::string_view getSession () const { return std::string_view(&blockData_->Session[0], 3);}

	//Firm ID
	[[nodiscard]] std::string_view getFirm () const { return std::string_view(&blockData_->Firm[0], 5);}

	//The longest time in milliseconds the customer or CME could remain silent before sending a keep alive message
	[[nodiscard]] std::uint16_t getKeepAliveInterval () const { return blockData_->KeepAliveInterval;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::array<char, 32> HMACSignature;
		std::array<char, 20> AccessKeyID;
		std::array<char, 30> TradingSystemName;
		std::array<char, 10> TradingSystemVersion;
		std::array<char, 10> TradingSystemVendor;
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::uint32_t NextSeqNo;
		std::array<char, 3> Session;
		std::array<char, 5> Firm;
		std::uint16_t KeepAliveInterval;
	};

	const BlockData *blockData_{nullptr};

	IL3Composite::Data data_;
};


class EstablishMsgOut: public EstablishMsg {
public:
	inline static const std::size_t blockLength {132};
	//static_assert (EstablishMsgOut::blockLength==sizeof (EstablishMsgOut::BlockData));

	EstablishMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Contains the HMAC signature
	void setHMACSignature (std::string_view v) { (void) v;}

	//Contains the AccessKeyID assigned to this session on this port
	void setAccessKeyID (std::string_view v) { (void) v;}

	//Provides the name of the application system being used to generate FIX application messages.
	void setTradingSystemName (std::string_view v) { (void) v;}

	//Provides the version of the application system being used to initiate FIX application messages.
	void setTradingSystemVersion (std::string_view v) { (void) v;}

	//Provides the vendor of the application system
	void setTradingSystemVendor (std::string_view v) { (void) v;}

	//Session Identifier defined as type long (uInt64); recommended to use timestamp as number of microseconds since epoch (Jan 1, 1970)
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Next expected message sequence number
	void setNextSeqNo (std::uint32_t v) { blockDataWrite_.NextSeqNo=v;}

	//Session ID
	void setSession (std::string_view v) { (void) v;}

	//Firm ID
	void setFirm (std::string_view v) { (void) v;}

	//The longest time in milliseconds the customer or CME could remain silent before sending a keep alive message
	void setKeepAliveInterval (std::uint16_t v) { blockDataWrite_.KeepAliveInterval=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class EstablishmentAckMsg {
public:
	inline static const std::size_t id{504};

	//Matches Establish.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Matches Establish.RequestTimestamp
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Next expected message sequence number
	[[nodiscard]] std::uint32_t getNextSeqNo () const { return blockData_->NextSeqNo;}

	//Refers to the SeqNum sent in the previous message before this one from CME
	[[nodiscard]] std::uint32_t getPreviousSeqNo () const { return blockData_->PreviousSeqNo;}

	//Refers to the UUID sent in the previous message before this one from CME
	[[nodiscard]] std::uint64_t getPreviousUUID () const { return blockData_->PreviousUUID;}

	//The longest time in milliseconds the customer or CME could remain silent before sending a keep alive message
	[[nodiscard]] std::uint16_t getKeepAliveInterval () const { return blockData_->KeepAliveInterval;}

	//This indicates in how many days the HMAC secret key will expire
	[[nodiscard]] std::uint16_t getSecretKeySecureIDExpiration () const { return blockData_->SecretKeySecureIDExpiration;}

	//Indicates whether the connection is primary or backup
	[[nodiscard]] IL3Enum::FTI getFaultToleranceIndicator () const { return blockData_->FaultToleranceIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::uint32_t NextSeqNo;
		std::uint32_t PreviousSeqNo;
		std::uint64_t PreviousUUID;
		std::uint16_t KeepAliveInterval;
		std::uint16_t SecretKeySecureIDExpiration {65535UL};
		IL3Enum::FTI FaultToleranceIndicator {IL3Enum::FTI::Null};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class EstablishmentAckMsgOut: public EstablishmentAckMsg {
public:
	inline static const std::size_t blockLength {38};
	//static_assert (EstablishmentAckMsgOut::blockLength==sizeof (EstablishmentAckMsgOut::BlockData));

	EstablishmentAckMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Matches Establish.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Matches Establish.RequestTimestamp
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Next expected message sequence number
	void setNextSeqNo (std::uint32_t v) { blockDataWrite_.NextSeqNo=v;}

	//Refers to the SeqNum sent in the previous message before this one from CME
	void setPreviousSeqNo (std::uint32_t v) { blockDataWrite_.PreviousSeqNo=v;}

	//Refers to the UUID sent in the previous message before this one from CME
	void setPreviousUUID (std::uint64_t v) { blockDataWrite_.PreviousUUID=v;}

	//The longest time in milliseconds the customer or CME could remain silent before sending a keep alive message
	void setKeepAliveInterval (std::uint16_t v) { blockDataWrite_.KeepAliveInterval=v;}

	//This indicates in how many days the HMAC secret key will expire
	void setSecretKeySecureIDExpiration (std::uint16_t v) { blockDataWrite_.SecretKeySecureIDExpiration=v;}

	//Indicates whether the connection is primary or backup
	void setFaultToleranceIndicator (IL3Enum::FTI v) { blockDataWrite_.FaultToleranceIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class EstablishmentRejectMsg {
public:
	inline static const std::size_t id{505};

	//Reject reason details
	[[nodiscard]] std::string_view getReason () const { return std::string_view(&blockData_->Reason[0], 48);}

	//Matches Establish.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Matches Establish.RequestTimestamp
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Next expected message sequence number
	[[nodiscard]] std::uint32_t getNextSeqNo () const { return blockData_->NextSeqNo;}

	//Error code for reject reason
	[[nodiscard]] std::uint16_t getErrorCodes () const { return blockData_->ErrorCodes;}

	//Indicates whether the connection is primary or backup
	[[nodiscard]] IL3Enum::FTI getFaultToleranceIndicator () const { return blockData_->FaultToleranceIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::array<char, 48> Reason;
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::uint32_t NextSeqNo;
		std::uint16_t ErrorCodes;
		IL3Enum::FTI FaultToleranceIndicator {IL3Enum::FTI::Null};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class EstablishmentRejectMsgOut: public EstablishmentRejectMsg {
public:
	inline static const std::size_t blockLength {72};
	//static_assert (EstablishmentRejectMsgOut::blockLength==sizeof (EstablishmentRejectMsgOut::BlockData));

	EstablishmentRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Reject reason details
	void setReason (std::string_view v) { (void) v;}

	//Matches Establish.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Matches Establish.RequestTimestamp
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Next expected message sequence number
	void setNextSeqNo (std::uint32_t v) { blockDataWrite_.NextSeqNo=v;}

	//Error code for reject reason
	void setErrorCodes (std::uint16_t v) { blockDataWrite_.ErrorCodes=v;}

	//Indicates whether the connection is primary or backup
	void setFaultToleranceIndicator (IL3Enum::FTI v) { blockDataWrite_.FaultToleranceIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class SequenceMsg {
public:
	inline static const std::size_t id{506};

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Next expected message sequence number
	[[nodiscard]] std::uint32_t getNextSeqNo () const { return blockData_->NextSeqNo;}

	//Indicates whether the connection is primary or backup
	[[nodiscard]] IL3Enum::FTI getFaultToleranceIndicator () const { return blockData_->FaultToleranceIndicator;}

	//This indicates if the Sequence message being sent by CME is to warn that one keep alive interval has lapsed without any message received from customer (this can also be sent from customer to CME)
	[[nodiscard]] IL3Enum::KeepAliveLapsed getKeepAliveIntervalLapsed () const { return blockData_->KeepAliveIntervalLapsed;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t UUID;
		std::uint32_t NextSeqNo;
		IL3Enum::FTI FaultToleranceIndicator {IL3Enum::FTI::Null};
		IL3Enum::KeepAliveLapsed KeepAliveIntervalLapsed;
	};

	const BlockData *blockData_{nullptr};
};


class SequenceMsgOut: public SequenceMsg {
public:
	inline static const std::size_t blockLength {14};
	//static_assert (SequenceMsgOut::blockLength==sizeof (SequenceMsgOut::BlockData));

	SequenceMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Next expected message sequence number
	void setNextSeqNo (std::uint32_t v) { blockDataWrite_.NextSeqNo=v;}

	//Indicates whether the connection is primary or backup
	void setFaultToleranceIndicator (IL3Enum::FTI v) { blockDataWrite_.FaultToleranceIndicator=v;}

	//This indicates if the Sequence message being sent by CME is to warn that one keep alive interval has lapsed without any message received from customer (this can also be sent from customer to CME)
	void setKeepAliveIntervalLapsed (IL3Enum::KeepAliveLapsed v) { blockDataWrite_.KeepAliveIntervalLapsed=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class TerminateMsg {
public:
	inline static const std::size_t id{507};

	//Reject reason details
	[[nodiscard]] std::string_view getReason () const { return std::string_view(&blockData_->Reason[0], 48);}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Error code for reject reason
	[[nodiscard]] std::uint16_t getErrorCodes () const { return blockData_->ErrorCodes;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::array<char, 48> Reason;
		std::uint64_t UUID;
		std::uint64_t RequestTimestamp;
		std::uint16_t ErrorCodes;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class TerminateMsgOut: public TerminateMsg {
public:
	inline static const std::size_t blockLength {67};
	//static_assert (TerminateMsgOut::blockLength==sizeof (TerminateMsgOut::BlockData));

	TerminateMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Reject reason details
	void setReason (std::string_view v) { (void) v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Error code for reject reason
	void setErrorCodes (std::uint16_t v) { blockDataWrite_.ErrorCodes=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class RetransmitRequestMsg {
public:
	inline static const std::size_t id{508};

	//Matches Establish.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//If RetransmitRequest is for a previous UUID then put that here otherwise put default null value
	[[nodiscard]] std::uint64_t getLastUUID () const { return blockData_->LastUUID;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Sequence number of the first business message requested. This should not be greater than the latest sequence number from CME
	[[nodiscard]] std::uint32_t getFromSeqNo () const { return blockData_->FromSeqNo;}

	//Count of business messages requested
	[[nodiscard]] std::uint16_t getMsgCount () const { return blockData_->MsgCount;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t UUID;
		std::uint64_t LastUUID {18446744073709551615UL};
		std::uint64_t RequestTimestamp;
		std::uint32_t FromSeqNo;
		std::uint16_t MsgCount;
	};

	const BlockData *blockData_{nullptr};
};


class RetransmitRequestMsgOut: public RetransmitRequestMsg {
public:
	inline static const std::size_t blockLength {30};
	//static_assert (RetransmitRequestMsgOut::blockLength==sizeof (RetransmitRequestMsgOut::BlockData));

	RetransmitRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Matches Establish.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//If RetransmitRequest is for a previous UUID then put that here otherwise put default null value
	void setLastUUID (std::uint64_t v) { blockDataWrite_.LastUUID=v;}

	//Time of request; recommended to use timestamp as number of nanoseconds since epoch (Jan 1, 1970)
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Sequence number of the first business message requested. This should not be greater than the latest sequence number from CME
	void setFromSeqNo (std::uint32_t v) { blockDataWrite_.FromSeqNo=v;}

	//Count of business messages requested
	void setMsgCount (std::uint16_t v) { blockDataWrite_.MsgCount=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class RetransmissionMsg {
public:
	inline static const std::size_t id{509};

	//Matches RetransmitRequest.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Matches RetransmitRequest.LastUUID
	[[nodiscard]] std::uint64_t getLastUUID () const { return blockData_->LastUUID;}

	//Matches RetransmitRequest.RequestTimestamp
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Matches RetransmitRequest.FromSeqNo
	[[nodiscard]] std::uint32_t getFromSeqNo () const { return blockData_->FromSeqNo;}

	//Matches RetransmitRequest.MsgCount
	[[nodiscard]] std::uint16_t getMsgCount () const { return blockData_->MsgCount;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t UUID;
		std::uint64_t LastUUID {18446744073709551615UL};
		std::uint64_t RequestTimestamp;
		std::uint32_t FromSeqNo;
		std::uint16_t MsgCount;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class RetransmissionMsgOut: public RetransmissionMsg {
public:
	inline static const std::size_t blockLength {31};
	//static_assert (RetransmissionMsgOut::blockLength==sizeof (RetransmissionMsgOut::BlockData));

	RetransmissionMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Matches RetransmitRequest.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Matches RetransmitRequest.LastUUID
	void setLastUUID (std::uint64_t v) { blockDataWrite_.LastUUID=v;}

	//Matches RetransmitRequest.RequestTimestamp
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Matches RetransmitRequest.FromSeqNo
	void setFromSeqNo (std::uint32_t v) { blockDataWrite_.FromSeqNo=v;}

	//Matches RetransmitRequest.MsgCount
	void setMsgCount (std::uint16_t v) { blockDataWrite_.MsgCount=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class RetransmitRejectMsg {
public:
	inline static const std::size_t id{510};

	//Reject reason details
	[[nodiscard]] std::string_view getReason () const { return std::string_view(&blockData_->Reason[0], 48);}

	//Matches RetransmitRequest.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Matches RetransmitRequest.LastUUID
	[[nodiscard]] std::uint64_t getLastUUID () const { return blockData_->LastUUID;}

	//Matches RetransmitRequest.RequestTimestamp
	[[nodiscard]] std::uint64_t getRequestTimestamp () const { return blockData_->RequestTimestamp;}

	//Error code for reject reason
	[[nodiscard]] std::uint16_t getErrorCodes () const { return blockData_->ErrorCodes;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::array<char, 48> Reason;
		std::uint64_t UUID;
		std::uint64_t LastUUID {18446744073709551615UL};
		std::uint64_t RequestTimestamp;
		std::uint16_t ErrorCodes;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class RetransmitRejectMsgOut: public RetransmitRejectMsg {
public:
	inline static const std::size_t blockLength {75};
	//static_assert (RetransmitRejectMsgOut::blockLength==sizeof (RetransmitRejectMsgOut::BlockData));

	RetransmitRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Reject reason details
	void setReason (std::string_view v) { (void) v;}

	//Matches RetransmitRequest.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Matches RetransmitRequest.LastUUID
	void setLastUUID (std::uint64_t v) { blockDataWrite_.LastUUID=v;}

	//Matches RetransmitRequest.RequestTimestamp
	void setRequestTimestamp (std::uint64_t v) { blockDataWrite_.RequestTimestamp=v;}

	//Error code for reject reason
	void setErrorCodes (std::uint16_t v) { blockDataWrite_.ErrorCodes=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class NotAppliedMsg {
public:
	inline static const std::size_t id{513};

	//Matches Establish.UUID
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//First not applied sequence number
	[[nodiscard]] std::uint32_t getFromSeqNo () const { return blockData_->FromSeqNo;}

	//Count of how many messages have not been applied
	[[nodiscard]] std::uint32_t getMsgCount () const { return blockData_->MsgCount;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order. This is applicable only to the incoming message which triggers the gap detection and is not reflective of whether any message sent earlier as part of that sequence gap and not received by CME was delayed or not
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t UUID;
		std::uint32_t FromSeqNo;
		std::uint32_t MsgCount;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class NotAppliedMsgOut: public NotAppliedMsg {
public:
	inline static const std::size_t blockLength {17};
	//static_assert (NotAppliedMsgOut::blockLength==sizeof (NotAppliedMsgOut::BlockData));

	NotAppliedMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Matches Establish.UUID
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//First not applied sequence number
	void setFromSeqNo (std::uint32_t v) { blockDataWrite_.FromSeqNo=v;}

	//Count of how many messages have not been applied
	void setMsgCount (std::uint32_t v) { blockDataWrite_.MsgCount=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order. This is applicable only to the incoming message which triggers the gap detection and is not reflective of whether any message sent earlier as part of that sequence gap and not received by CME was delayed or not
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class NewOrderSingleMsg {
public:
	inline static const std::size_t id{514};

	//Number of shares or contracts ordered
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Minimum quantity of an order to be executed
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date. Applicable only to GTD orders which expire at the end of the trading session specified. This has to be a future or current session date and cannot be in the past.
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Order type
	[[nodiscard]] IL3Enum::OrderTypeReq getOrdType () const { return blockData_->OrdType;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t OrderQty;
		std::int32_t SecurityID;
		IL3Enum::SideReq Side;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderRequestID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		IL3Enum::OrderTypeReq OrdType;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class NewOrderSingleMsgOut: public NewOrderSingleMsg {
public:
	inline static const std::size_t blockLength {116};
	//static_assert (NewOrderSingleMsgOut::blockLength==sizeof (NewOrderSingleMsgOut::BlockData));

	NewOrderSingleMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Number of shares or contracts ordered
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Minimum quantity of an order to be executed
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date. Applicable only to GTD orders which expire at the end of the trading session specified. This has to be a future or current session date and cannot be in the past.
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Order type
	void setOrdType (IL3Enum::OrderTypeReq v) { blockDataWrite_.OrdType=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderCancelReplaceRequestMsg {
public:
	inline static const std::size_t id{515};

	//Number of shares or contracts ordered
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Minimum quantity of an order to be executed
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//Maximum number of shares or contracts within an order to be shown on the match engine at any given time
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date. Applicable only to GTD orders which expire at the end of the trading session specified. This has to be a future or current session date and cannot be in the past.
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Order type
	[[nodiscard]] IL3Enum::OrderTypeReq getOrdType () const { return blockData_->OrdType;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flag indicating whether the order quantity stipulated on replace request should be entered into the market as stated without reduction for any fills that have occurred. Also once enabled in the order chain it cannot be disabled
	[[nodiscard]] IL3Enum::OFMOverrideReq getOFMOverride () const { return blockData_->OFMOverride;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t OrderQty;
		std::int32_t SecurityID;
		IL3Enum::SideReq Side;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t OrderRequestID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		IL3Enum::OrderTypeReq OrdType;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::OFMOverrideReq OFMOverride;
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class OrderCancelReplaceRequestMsgOut: public OrderCancelReplaceRequestMsg {
public:
	inline static const std::size_t blockLength {125};
	//static_assert (OrderCancelReplaceRequestMsgOut::blockLength==sizeof (OrderCancelReplaceRequestMsgOut::BlockData));

	OrderCancelReplaceRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Number of shares or contracts ordered
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Minimum quantity of an order to be executed
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//Maximum number of shares or contracts within an order to be shown on the match engine at any given time
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date. Applicable only to GTD orders which expire at the end of the trading session specified. This has to be a future or current session date and cannot be in the past.
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Order type
	void setOrdType (IL3Enum::OrderTypeReq v) { blockDataWrite_.OrdType=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flag indicating whether the order quantity stipulated on replace request should be entered into the market as stated without reduction for any fills that have occurred. Also once enabled in the order chain it cannot be disabled
	void setOFMOverride (IL3Enum::OFMOverrideReq v) { blockDataWrite_.OFMOverride=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderCancelRequestMsg {
public:
	inline static const std::size_t id{516};

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages. Falcon ignores the incoming value except when null and returns back the correct one in the outgoing execution report.
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Side of order.
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t OrderID;
		std::uint64_t PartyDetailsListReqID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t OrderRequestID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		IL3Enum::SideReq Side;
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
	};

	const BlockData *blockData_{nullptr};
};


class OrderCancelRequestMsgOut: public OrderCancelRequestMsg {
public:
	inline static const std::size_t blockLength {88};
	//static_assert (OrderCancelRequestMsgOut::blockLength==sizeof (OrderCancelRequestMsgOut::BlockData));

	OrderCancelRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages. Falcon ignores the incoming value except when null and returns back the correct one in the outgoing execution report.
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Side of order.
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class MassQuoteMsg {
public:
	inline static const std::size_t id{517};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Indicates if the order was initially received manually (as opposed to electronically). Reject if greater than max length. Flip back incoming value in outgoing execution report only if either Y/N otherwise ignore. 
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for quote request being responded to
	[[nodiscard]] std::uint64_t getQuoteReqID () const { return blockData_->QuoteReqID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Unique identifier for mass quote populated by the client system
	[[nodiscard]] std::uint32_t getQuoteID () const { return blockData_->QuoteID;}

	//Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set. Required if NoQuoteEntries > 0. Since fragmentation is not supported in practice this will always be equal to the value of NoQuoteEntries
	[[nodiscard]] std::uint8_t getTotNoQuoteEntries () const { return blockData_->TotNoQuoteEntries;}

	//When market maker protection is triggered CME will not accept any new quotes from the market maker for that product group until it receives a mass quote message with the MMProtectionReset flag set to true
	[[nodiscard]] IL3Enum::BooleanFlag getMMProtectionReset () const { return blockData_->MMProtectionReset;}

	//New field added to capture if an order was submitted for market making obligation or not for MiFID
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Reserved for future use
	[[nodiscard]] std::string_view getReserved () const { return std::string_view(&blockData_->Reserved[0], 30);}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SendingTimeEpoch;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t QuoteReqID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::uint32_t QuoteID;
		std::uint8_t TotNoQuoteEntries;
		IL3Enum::BooleanFlag MMProtectionReset;
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::array<char, 30> Reserved;
	};

	const BlockData *blockData_{nullptr};
};


class MassQuoteMsgOut: public MassQuoteMsg {
public:
	inline static const std::size_t blockLength {92};
	//static_assert (MassQuoteMsgOut::blockLength==sizeof (MassQuoteMsgOut::BlockData));

	MassQuoteMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Indicates if the order was initially received manually (as opposed to electronically). Reject if greater than max length. Flip back incoming value in outgoing execution report only if either Y/N otherwise ignore. 
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for quote request being responded to
	void setQuoteReqID (std::uint64_t v) { blockDataWrite_.QuoteReqID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Unique identifier for mass quote populated by the client system
	void setQuoteID (std::uint32_t v) { blockDataWrite_.QuoteID=v;}

	//Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set. Required if NoQuoteEntries > 0. Since fragmentation is not supported in practice this will always be equal to the value of NoQuoteEntries
	void setTotNoQuoteEntries (std::uint8_t v) { blockDataWrite_.TotNoQuoteEntries=v;}

	//When market maker protection is triggered CME will not accept any new quotes from the market maker for that product group until it receives a mass quote message with the MMProtectionReset flag set to true
	void setMMProtectionReset (IL3Enum::BooleanFlag v) { blockDataWrite_.MMProtectionReset=v;}

	//New field added to capture if an order was submitted for market making obligation or not for MiFID
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Reserved for future use
	void setReserved (std::string_view v) { (void) v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class PartyDetailsDefinitionRequestMsg {
public:
	inline static const std::size_t id{518};

	//The unique identifier of the PartyDetailsDefinitionRequest(35=CX) message. For use with short messages and registering party details through iLink this ID should be unique. For use with long messages this ID should be set to FFFFFFFF
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Indicates if all of the information sent in this message with a unique new PartyDetailsListRequestID is a new addition or deletion of existing information associated with an existing PartyDetailsListRequestID. For PartyDetailsListRequestID=FFFFFFFF this should always be set to "A"
	[[nodiscard]] IL3Enum::ListUpdAct getListUpdateAction () const { return blockData_->ListUpdateAction;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//This general purpose text field could be mapped from iLink to Clearing STP for trades. Not available for use with the short format where PartyDetailsListRequestID not equal to FFFFFFFF. Available for use only with the long format where PartyDetailsListRequestID=FFFFFFFF
	[[nodiscard]] std::string_view getMemo () const { return std::string_view(&blockData_->Memo[0], 75);}

	//Used by submitting firm to group trades being allocated into an average price group. The trades in average price group will be used to calculate an average price for the group
	[[nodiscard]] std::string_view getAvgPxGroupID () const { return std::string_view(&blockData_->AvgPxGroupID[0], 20);}

	//Identifies an order or trade that should not be matched to an opposite order or trade if both buy and sell orders for the same asset contain the same SelfMatchPreventionID (2362) and submitted by the same firm
	[[nodiscard]] std::uint64_t getSelfMatchPreventionID () const { return blockData_->SelfMatchPreventionID;}

	//Indicates if the order is a give-up or SGX offset. Reject if greater than max length or not containing valid value. 
	[[nodiscard]] IL3Enum::CmtaGiveUpCD getCmtaGiveupCD () const { return blockData_->CmtaGiveupCD;}

	//Capacity of customer placing the order. Used by futures exchanges to indicate the CTICode (customer type indicator) as required by the US CFTC (Commodity Futures Trading Commission)
	[[nodiscard]] IL3Enum::CustOrderCapacity getCustOrderCapacity () const { return blockData_->CustOrderCapacity;}

	//Designates the account type to be used for the order when submitted to clearing
	[[nodiscard]] IL3Enum::ClearingAcctType getClearingAccountType () const { return blockData_->ClearingAccountType;}

	//Used to act upon the outcome when a self-match is detected and an order is prevented from trading against another order with the same SelfMatchPreventionID (Tag 2362). 1=Cancel newest signifies that incoming order is cancelled. 2=Cancel Oldest signifies that the resting order is cancelled. Absence of this field (with Tag 2362) is interpreted as cancel oldest
	[[nodiscard]] IL3Enum::SMPI getSelfMatchPreventionInstruction () const { return blockData_->SelfMatchPreventionInstruction;}

	//Average pricing indicator
	[[nodiscard]] IL3Enum::AvgPxInd getAvgPxIndicator () const { return blockData_->AvgPxIndicator;}

	//Indicates to recipient whether trade is clearing at execution prices LastPx (tag 31) or alternate clearing price (prior day settlement price)
	[[nodiscard]] IL3Enum::SLEDS getClearingTradePriceType () const { return blockData_->ClearingTradePriceType;}

	//Codes that apply special information that the Broker / Dealer needs to report, as specified by the customer. Defines source of the order 
	[[nodiscard]] IL3Enum::CustOrdHandlInst getCustOrderHandlingInst () const { return blockData_->CustOrderHandlingInst;}

	//Will be populated with a short code for the person or algo identified in FIX tag 5392 which will be mapped to National ID or Algo at reporting time. Applicable for EU fixed income markets only
	[[nodiscard]] std::uint64_t getExecutor () const { return blockData_->Executor;}

	//Represents the Investment Decision Maker Short Code. Applicable for EU fixed income markets only
	[[nodiscard]] std::uint64_t getIDMShortCode () const { return blockData_->IDMShortCode;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SendingTimeEpoch;
		IL3Enum::ListUpdAct ListUpdateAction;
		std::uint32_t SeqNum;
		std::array<char, 75> Memo;
		std::array<char, 20> AvgPxGroupID;
		std::uint64_t SelfMatchPreventionID {18446744073709551615UL};
		IL3Enum::CmtaGiveUpCD CmtaGiveupCD {IL3Enum::CmtaGiveUpCD::Null};
		IL3Enum::CustOrderCapacity CustOrderCapacity {IL3Enum::CustOrderCapacity::Null};
		IL3Enum::ClearingAcctType ClearingAccountType {IL3Enum::ClearingAcctType::Null};
		IL3Enum::SMPI SelfMatchPreventionInstruction {IL3Enum::SMPI::Null};
		IL3Enum::AvgPxInd AvgPxIndicator {IL3Enum::AvgPxInd::Null};
		IL3Enum::SLEDS ClearingTradePriceType {IL3Enum::SLEDS::Null};
		IL3Enum::CustOrdHandlInst CustOrderHandlingInst {IL3Enum::CustOrdHandlInst::Null};
		std::uint64_t Executor {18446744073709551615UL};
		std::uint64_t IDMShortCode {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class PartyDetailsDefinitionRequestMsgOut: public PartyDetailsDefinitionRequestMsg {
public:
	inline static const std::size_t blockLength {147};
	//static_assert (PartyDetailsDefinitionRequestMsgOut::blockLength==sizeof (PartyDetailsDefinitionRequestMsgOut::BlockData));

	PartyDetailsDefinitionRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//The unique identifier of the PartyDetailsDefinitionRequest(35=CX) message. For use with short messages and registering party details through iLink this ID should be unique. For use with long messages this ID should be set to FFFFFFFF
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Indicates if all of the information sent in this message with a unique new PartyDetailsListRequestID is a new addition or deletion of existing information associated with an existing PartyDetailsListRequestID. For PartyDetailsListRequestID=FFFFFFFF this should always be set to "A"
	void setListUpdateAction (IL3Enum::ListUpdAct v) { blockDataWrite_.ListUpdateAction=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//This general purpose text field could be mapped from iLink to Clearing STP for trades. Not available for use with the short format where PartyDetailsListRequestID not equal to FFFFFFFF. Available for use only with the long format where PartyDetailsListRequestID=FFFFFFFF
	void setMemo (std::string_view v) { (void) v;}

	//Used by submitting firm to group trades being allocated into an average price group. The trades in average price group will be used to calculate an average price for the group
	void setAvgPxGroupID (std::string_view v) { (void) v;}

	//Identifies an order or trade that should not be matched to an opposite order or trade if both buy and sell orders for the same asset contain the same SelfMatchPreventionID (2362) and submitted by the same firm
	void setSelfMatchPreventionID (std::uint64_t v) { blockDataWrite_.SelfMatchPreventionID=v;}

	//Indicates if the order is a give-up or SGX offset. Reject if greater than max length or not containing valid value. 
	void setCmtaGiveupCD (IL3Enum::CmtaGiveUpCD v) { blockDataWrite_.CmtaGiveupCD=v;}

	//Capacity of customer placing the order. Used by futures exchanges to indicate the CTICode (customer type indicator) as required by the US CFTC (Commodity Futures Trading Commission)
	void setCustOrderCapacity (IL3Enum::CustOrderCapacity v) { blockDataWrite_.CustOrderCapacity=v;}

	//Designates the account type to be used for the order when submitted to clearing
	void setClearingAccountType (IL3Enum::ClearingAcctType v) { blockDataWrite_.ClearingAccountType=v;}

	//Used to act upon the outcome when a self-match is detected and an order is prevented from trading against another order with the same SelfMatchPreventionID (Tag 2362). 1=Cancel newest signifies that incoming order is cancelled. 2=Cancel Oldest signifies that the resting order is cancelled. Absence of this field (with Tag 2362) is interpreted as cancel oldest
	void setSelfMatchPreventionInstruction (IL3Enum::SMPI v) { blockDataWrite_.SelfMatchPreventionInstruction=v;}

	//Average pricing indicator
	void setAvgPxIndicator (IL3Enum::AvgPxInd v) { blockDataWrite_.AvgPxIndicator=v;}

	//Indicates to recipient whether trade is clearing at execution prices LastPx (tag 31) or alternate clearing price (prior day settlement price)
	void setClearingTradePriceType (IL3Enum::SLEDS v) { blockDataWrite_.ClearingTradePriceType=v;}

	//Codes that apply special information that the Broker / Dealer needs to report, as specified by the customer. Defines source of the order 
	void setCustOrderHandlingInst (IL3Enum::CustOrdHandlInst v) { blockDataWrite_.CustOrderHandlingInst=v;}

	//Will be populated with a short code for the person or algo identified in FIX tag 5392 which will be mapped to National ID or Algo at reporting time. Applicable for EU fixed income markets only
	void setExecutor (std::uint64_t v) { blockDataWrite_.Executor=v;}

	//Represents the Investment Decision Maker Short Code. Applicable for EU fixed income markets only
	void setIDMShortCode (std::uint64_t v) { blockDataWrite_.IDMShortCode=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class PartyDetailsDefinitionRequestAckMsg {
public:
	inline static const std::size_t id{519};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//This general purpose text field could be mapped from iLink to Clearing STP for trades
	[[nodiscard]] std::string_view getMemo () const { return std::string_view(&blockData_->Memo[0], 75);}

	//Used by submitting firm to group trades being allocated into an average price group. The trades in average price group will be used to calculate an average price for the group
	[[nodiscard]] std::string_view getAvgPxGroupID () const { return std::string_view(&blockData_->AvgPxGroupID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequest(35=CX) message. For use with short messages and registering party details through iLink this ID should be unique. For use with long messages this ID should be set to FFFFFFFF
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Used by the Falcon engine to prevent orders from the same firm matching with each other. Each message sent with this tag and the same matching value will be eligible for Self-Match Prevention.
	[[nodiscard]] std::uint64_t getSelfMatchPreventionID () const { return blockData_->SelfMatchPreventionID;}

	//Status of party details definition request
	[[nodiscard]] std::uint8_t getPartyDetailRequestStatus () const { return blockData_->PartyDetailRequestStatus;}

	//Capacity of customer placing the order. Used by futures exchanges to indicate the CTICode (customer type indicator) as required by the US CFTC (Commodity Futures Trading Commission)
	[[nodiscard]] IL3Enum::CustOrderCapacity getCustOrderCapacity () const { return blockData_->CustOrderCapacity;}

	//Designates the account type to be used for the order when submitted to clearing
	[[nodiscard]] IL3Enum::ClearingAcctType getClearingAccountType () const { return blockData_->ClearingAccountType;}

	//Used to act upon the outcome when a self-match is detected and an order is prevented from trading against another order with the same SelfMatchPreventionID (Tag 2362). N=Cancel newest signifies that incoming order is cancelled. O=Cancel Oldest signifies that the resting order is cancelled. Absence of this field (with Tag 2362) is interpreted as cancel oldest
	[[nodiscard]] IL3Enum::SMPI getSelfMatchPreventionInstruction () const { return blockData_->SelfMatchPreventionInstruction;}

	//Indicates if the resulting trade is to be average priced or not. Is also used to indicate type of average price grouping
	[[nodiscard]] IL3Enum::AvgPxInd getAvgPxIndicator () const { return blockData_->AvgPxIndicator;}

	//Indicates whether spread differential trade is clearing at execution price (LastPx Tag 31) or alternate clearing price (prior day settle price)
	[[nodiscard]] IL3Enum::SLEDS getClearingTradePriceType () const { return blockData_->ClearingTradePriceType;}

	//Indicates if the order is a give-up or SGX offset
	[[nodiscard]] IL3Enum::CmtaGiveUpCD getCmtaGiveupCD () const { return blockData_->CmtaGiveupCD;}

	//Codes that apply special information that the Broker / Dealer needs to report, as specified by the customer. Defines source of the order 
	[[nodiscard]] IL3Enum::CustOrdHandlInst getCustOrderHandlingInst () const { return blockData_->CustOrderHandlingInst;}

	//Indicates if all of the information sent in this message with a unique new PartyDetailsListRequestID is a new addition or deletion of existing information (TBD) associated with an existing PartyDetailsListRequestID. For PartyDetailsListRequestID=FFFFFFFF this should always be set to "A"
	[[nodiscard]] IL3Enum::ListUpdAct getListUpdateAction () const { return blockData_->ListUpdateAction;}

	//Status of party detail definition for one party
	[[nodiscard]] std::uint8_t getPartyDetailDefinitionStatus () const { return blockData_->PartyDetailDefinitionStatus;}

	//Will be populated with a short code for the person or algo identified in FIX tag 5392 which will be mapped to National ID or Algo at reporting time
	[[nodiscard]] std::uint64_t getExecutor () const { return blockData_->Executor;}

	//Represents the Investment Decision Maker Short Code
	[[nodiscard]] std::uint64_t getIDMShortCode () const { return blockData_->IDMShortCode;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 75> Memo;
		std::array<char, 20> AvgPxGroupID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t SelfMatchPreventionID {18446744073709551615UL};
		std::uint8_t PartyDetailRequestStatus;
		IL3Enum::CustOrderCapacity CustOrderCapacity {IL3Enum::CustOrderCapacity::Null};
		IL3Enum::ClearingAcctType ClearingAccountType {IL3Enum::ClearingAcctType::Null};
		IL3Enum::SMPI SelfMatchPreventionInstruction {IL3Enum::SMPI::Null};
		IL3Enum::AvgPxInd AvgPxIndicator {IL3Enum::AvgPxInd::Null};
		IL3Enum::SLEDS ClearingTradePriceType {IL3Enum::SLEDS::Null};
		IL3Enum::CmtaGiveUpCD CmtaGiveupCD {IL3Enum::CmtaGiveUpCD::Null};
		IL3Enum::CustOrdHandlInst CustOrderHandlingInst {IL3Enum::CustOrdHandlInst::Null};
		IL3Enum::ListUpdAct ListUpdateAction;
		std::uint8_t PartyDetailDefinitionStatus;
		std::uint64_t Executor {18446744073709551615UL};
		std::uint64_t IDMShortCode {18446744073709551615UL};
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class PartyDetailsDefinitionRequestAckMsgOut: public PartyDetailsDefinitionRequestAckMsg {
public:
	inline static const std::size_t blockLength {159};
	//static_assert (PartyDetailsDefinitionRequestAckMsgOut::blockLength==sizeof (PartyDetailsDefinitionRequestAckMsgOut::BlockData));

	PartyDetailsDefinitionRequestAckMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//This general purpose text field could be mapped from iLink to Clearing STP for trades
	void setMemo (std::string_view v) { (void) v;}

	//Used by submitting firm to group trades being allocated into an average price group. The trades in average price group will be used to calculate an average price for the group
	void setAvgPxGroupID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequest(35=CX) message. For use with short messages and registering party details through iLink this ID should be unique. For use with long messages this ID should be set to FFFFFFFF
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Used by the Falcon engine to prevent orders from the same firm matching with each other. Each message sent with this tag and the same matching value will be eligible for Self-Match Prevention.
	void setSelfMatchPreventionID (std::uint64_t v) { blockDataWrite_.SelfMatchPreventionID=v;}

	//Status of party details definition request
	void setPartyDetailRequestStatus (std::uint8_t v) { blockDataWrite_.PartyDetailRequestStatus=v;}

	//Capacity of customer placing the order. Used by futures exchanges to indicate the CTICode (customer type indicator) as required by the US CFTC (Commodity Futures Trading Commission)
	void setCustOrderCapacity (IL3Enum::CustOrderCapacity v) { blockDataWrite_.CustOrderCapacity=v;}

	//Designates the account type to be used for the order when submitted to clearing
	void setClearingAccountType (IL3Enum::ClearingAcctType v) { blockDataWrite_.ClearingAccountType=v;}

	//Used to act upon the outcome when a self-match is detected and an order is prevented from trading against another order with the same SelfMatchPreventionID (Tag 2362). N=Cancel newest signifies that incoming order is cancelled. O=Cancel Oldest signifies that the resting order is cancelled. Absence of this field (with Tag 2362) is interpreted as cancel oldest
	void setSelfMatchPreventionInstruction (IL3Enum::SMPI v) { blockDataWrite_.SelfMatchPreventionInstruction=v;}

	//Indicates if the resulting trade is to be average priced or not. Is also used to indicate type of average price grouping
	void setAvgPxIndicator (IL3Enum::AvgPxInd v) { blockDataWrite_.AvgPxIndicator=v;}

	//Indicates whether spread differential trade is clearing at execution price (LastPx Tag 31) or alternate clearing price (prior day settle price)
	void setClearingTradePriceType (IL3Enum::SLEDS v) { blockDataWrite_.ClearingTradePriceType=v;}

	//Indicates if the order is a give-up or SGX offset
	void setCmtaGiveupCD (IL3Enum::CmtaGiveUpCD v) { blockDataWrite_.CmtaGiveupCD=v;}

	//Codes that apply special information that the Broker / Dealer needs to report, as specified by the customer. Defines source of the order 
	void setCustOrderHandlingInst (IL3Enum::CustOrdHandlInst v) { blockDataWrite_.CustOrderHandlingInst=v;}

	//Indicates if all of the information sent in this message with a unique new PartyDetailsListRequestID is a new addition or deletion of existing information (TBD) associated with an existing PartyDetailsListRequestID. For PartyDetailsListRequestID=FFFFFFFF this should always be set to "A"
	void setListUpdateAction (IL3Enum::ListUpdAct v) { blockDataWrite_.ListUpdateAction=v;}

	//Status of party detail definition for one party
	void setPartyDetailDefinitionStatus (std::uint8_t v) { blockDataWrite_.PartyDetailDefinitionStatus=v;}

	//Will be populated with a short code for the person or algo identified in FIX tag 5392 which will be mapped to National ID or Algo at reporting time
	void setExecutor (std::uint64_t v) { blockDataWrite_.Executor=v;}

	//Represents the Investment Decision Maker Short Code
	void setIDMShortCode (std::uint64_t v) { blockDataWrite_.IDMShortCode=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class BusinessRejectMsg {
public:
	inline static const std::size_t id{521};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details. Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//The value of the business-level ID field on the message being referenced. Required unless the corresponding ID field was not specified.
	[[nodiscard]] std::uint64_t getBusinessRejectRefID () const { return blockData_->BusinessRejectRefID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Tag 9726 - SeqNum of the rejected message
	[[nodiscard]] std::uint32_t getRefSeqNum () const { return blockData_->RefSeqNum;}

	//The tag number of the FIX/FIXP field being referenced which is invalid
	[[nodiscard]] std::uint16_t getRefTagID () const { return blockData_->RefTagID;}

	//Code to identify reason for a Business Message Reject message
	[[nodiscard]] std::uint16_t getBusinessRejectReason () const { return blockData_->BusinessRejectReason;}

	//The MsgType of the FIX message being referenced.
	[[nodiscard]] std::string_view getRefMsgType () const { return std::string_view(&blockData_->RefMsgType[0], 2);}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates if order was sent manually or generated by automated trading logi
	[[nodiscard]] IL3Enum::ManualOrdInd getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 20> SenderID;
		std::uint64_t PartyDetailsListReqID {18446744073709551615UL};
		std::uint64_t SendingTimeEpoch;
		std::uint64_t BusinessRejectRefID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::uint32_t RefSeqNum {4294967295UL};
		std::uint16_t RefTagID {65535UL};
		std::uint16_t BusinessRejectReason;
		std::array<char, 2> RefMsgType;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::ManualOrdInd ManualOrderIndicator {IL3Enum::ManualOrdInd::Null};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class BusinessRejectMsgOut: public BusinessRejectMsg {
public:
	inline static const std::size_t blockLength {330};
	//static_assert (BusinessRejectMsgOut::blockLength==sizeof (BusinessRejectMsgOut::BlockData));

	BusinessRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details. Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//The value of the business-level ID field on the message being referenced. Required unless the corresponding ID field was not specified.
	void setBusinessRejectRefID (std::uint64_t v) { blockDataWrite_.BusinessRejectRefID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Tag 9726 - SeqNum of the rejected message
	void setRefSeqNum (std::uint32_t v) { blockDataWrite_.RefSeqNum=v;}

	//The tag number of the FIX/FIXP field being referenced which is invalid
	void setRefTagID (std::uint16_t v) { blockDataWrite_.RefTagID=v;}

	//Code to identify reason for a Business Message Reject message
	void setBusinessRejectReason (std::uint16_t v) { blockDataWrite_.BusinessRejectReason=v;}

	//The MsgType of the FIX message being referenced.
	void setRefMsgType (std::string_view v) { (void) v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates if order was sent manually or generated by automated trading logi
	void setManualOrderIndicator (IL3Enum::ManualOrdInd v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportNewMsg {
public:
	inline static const std::size_t id{522};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by the exchange and is unique per day across all instruments and across all good till orders.
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Order quantity submitted by client
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Minimum quantity of an order to be executed.
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date. Applicable only to GTD orders which expire at the end of the trading session specified
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if order was sent manually or generated by automated trading logic
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//ype of cross being submitted to a market. (if in response to a cross order)
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportNewMsgOut: public ExecutionReportNewMsg {
public:
	inline static const std::size_t blockLength {209};
	//static_assert (ExecutionReportNewMsgOut::blockLength==sizeof (ExecutionReportNewMsgOut::BlockData));

	ExecutionReportNewMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by the exchange and is unique per day across all instruments and across all good till orders.
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Order quantity submitted by client
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Minimum quantity of an order to be executed.
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date. Applicable only to GTD orders which expire at the end of the trading session specified
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if order was sent manually or generated by automated trading logic
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//ype of cross being submitted to a market. (if in response to a cross order)
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportRejectMsg {
public:
	inline static const std::size_t id{523};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details. Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Number of shares or contracts ordered.
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Minimum quantity of an order to be executed.
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Code to identify reason for order rejection
	[[nodiscard]] std::uint16_t getOrdRejReason () const { return blockData_->OrdRejReason;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Side of order.
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if order was sent manually or generated by automated trading logic 
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t OrdRejReason;
		std::uint16_t ExpireDate {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportRejectMsgOut: public ExecutionReportRejectMsg {
public:
	inline static const std::size_t blockLength {467};
	//static_assert (ExecutionReportRejectMsgOut::blockLength==sizeof (ExecutionReportRejectMsgOut::BlockData));

	ExecutionReportRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details. Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Number of shares or contracts ordered.
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Minimum quantity of an order to be executed.
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Code to identify reason for order rejection
	void setOrdRejReason (std::uint16_t v) { blockDataWrite_.OrdRejReason=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Side of order.
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if order was sent manually or generated by automated trading logic 
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportEliminationMsg {
public:
	inline static const std::size_t id{524};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//Order quantity submitted by client
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Minimum quantity of an order to be executed.
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Order type
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if order was sent manually or generated by automated trading logic
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Type of cross being submitted to a market. (if in response to a cross order)
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t CumQty;
		std::uint32_t OrderQty;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportEliminationMsgOut: public ExecutionReportEliminationMsg {
public:
	inline static const std::size_t blockLength {202};
	//static_assert (ExecutionReportEliminationMsgOut::blockLength==sizeof (ExecutionReportEliminationMsgOut::BlockData));

	ExecutionReportEliminationMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//Order quantity submitted by client
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Minimum quantity of an order to be executed.
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Order type
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if order was sent manually or generated by automated trading logic
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Type of cross being submitted to a market. (if in response to a cross order)
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportTradeOutrightMsg {
public:
	inline static const std::size_t id{525};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by the exchange; unique per day across all instruments and across all good till orders.
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Unique identifier that allows linking id spread summary fill notice with leg fill notice and trade cancel messages
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Number of shares or contracts ordered.
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Quantity of shares bought/sold on this (last) fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//Market Data Trade Entry ID. This identifier is assigned to all trades that take place for an instrument at a particular price level
	[[nodiscard]] std::uint32_t getMDTradeEntryID () const { return blockData_->MDTradeEntryID;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	[[nodiscard]] std::uint32_t getSideTradeID () const { return blockData_->SideTradeID;}

	//Contains the workup ID; unique per instrument per day
	[[nodiscard]] std::uint32_t getTradeLinkID () const { return blockData_->TradeLinkID;}

	//Quantity open for further execution;  LeavesQty = OrderQty (38) - CumQty (14); Only present for outrights and spreads and not spread legs
	[[nodiscard]] std::uint32_t getLeavesQty () const { return blockData_->LeavesQty;}

	//Indicates date of trading day (expressed in local time at place of trade).
	[[nodiscard]] std::uint16_t getTradeDate () const { return blockData_->TradeDate;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Identifies status of order as partially filled or completely filled
	[[nodiscard]] IL3Enum::OrdStatusTrd getOrdStatus () const { return blockData_->OrdStatus;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if order was sent manually or generated by automated trading logic
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates if order was incoming or resting for the match event
	[[nodiscard]] IL3Enum::BooleanFlag getAggressorIndicator () const { return blockData_->AggressorIndicator;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Specifies the owner of the work up private phase
	[[nodiscard]] std::uint8_t getOwnership () const { return blockData_->Ownership;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t SecExecID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t LastQty;
		std::uint32_t CumQty;
		std::uint32_t MDTradeEntryID;
		std::uint32_t SideTradeID;
		std::uint32_t TradeLinkID {4294967295UL};
		std::uint32_t LeavesQty;
		std::uint16_t TradeDate {65535UL};
		std::uint16_t ExpireDate {65535UL};
		IL3Enum::OrdStatusTrd OrdStatus;
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::BooleanFlag AggressorIndicator;
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::uint8_t Ownership;
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportTradeOutrightMsgOut: public ExecutionReportTradeOutrightMsg {
public:
	inline static const std::size_t blockLength {235};
	//static_assert (ExecutionReportTradeOutrightMsgOut::blockLength==sizeof (ExecutionReportTradeOutrightMsgOut::BlockData));

	ExecutionReportTradeOutrightMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by the exchange; unique per day across all instruments and across all good till orders.
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Unique identifier that allows linking id spread summary fill notice with leg fill notice and trade cancel messages
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Number of shares or contracts ordered.
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Quantity of shares bought/sold on this (last) fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//Market Data Trade Entry ID. This identifier is assigned to all trades that take place for an instrument at a particular price level
	void setMDTradeEntryID (std::uint32_t v) { blockDataWrite_.MDTradeEntryID=v;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	void setSideTradeID (std::uint32_t v) { blockDataWrite_.SideTradeID=v;}

	//Contains the workup ID; unique per instrument per day
	void setTradeLinkID (std::uint32_t v) { blockDataWrite_.TradeLinkID=v;}

	//Quantity open for further execution;  LeavesQty = OrderQty (38) - CumQty (14); Only present for outrights and spreads and not spread legs
	void setLeavesQty (std::uint32_t v) { blockDataWrite_.LeavesQty=v;}

	//Indicates date of trading day (expressed in local time at place of trade).
	void setTradeDate (std::uint16_t v) { blockDataWrite_.TradeDate=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Identifies status of order as partially filled or completely filled
	void setOrdStatus (IL3Enum::OrdStatusTrd v) { blockDataWrite_.OrdStatus=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if order was sent manually or generated by automated trading logic
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates if order was incoming or resting for the match event
	void setAggressorIndicator (IL3Enum::BooleanFlag v) { blockDataWrite_.AggressorIndicator=v;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Specifies the owner of the work up private phase
	void setOwnership (std::uint8_t v) { blockDataWrite_.Ownership=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportTradeSpreadMsg {
public:
	inline static const std::size_t id{526};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by the exchange; unique per day across all instruments and across all good till orders
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Unique identifier that allows linking id spread summary fill notice with leg fill notice and trade cancel messages
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Number of shares or contracts ordered.
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Quantity of shares bought/sold on this (last) fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//Market Data Trade Entry ID. This identifier is assigned to all trades that take place for an instrument at a particular price level
	[[nodiscard]] std::uint32_t getMDTradeEntryID () const { return blockData_->MDTradeEntryID;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	[[nodiscard]] std::uint32_t getSideTradeID () const { return blockData_->SideTradeID;}

	//Quantity open for further execution;  LeavesQty = OrderQty (38) - CumQty (14); Only present for outrights and spreads and not spread legs
	[[nodiscard]] std::uint32_t getLeavesQty () const { return blockData_->LeavesQty;}

	//Indicates date of trading day (expressed in local time at place of trade).
	[[nodiscard]] std::uint16_t getTradeDate () const { return blockData_->TradeDate;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Identifies status of order as partially filled or completely filled
	[[nodiscard]] IL3Enum::OrdStatusTrd getOrdStatus () const { return blockData_->OrdStatus;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if order was sent manually or generated by automated trading logic
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates if order was incoming or resting for the match event
	[[nodiscard]] IL3Enum::BooleanFlag getAggressorIndicator () const { return blockData_->AggressorIndicator;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Indicates total number of leg fills for the spread; Will represent total number of ExecutionReportTradeSpreadLeg messages sent for the spread and will be set to 0 when spread leg fills are consolidated with spread fill
	[[nodiscard]] std::uint8_t getTotalNumSecurities () const { return blockData_->TotalNumSecurities;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t SecExecID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t LastQty;
		std::uint32_t CumQty;
		std::uint32_t MDTradeEntryID;
		std::uint32_t SideTradeID;
		std::uint32_t LeavesQty;
		std::uint16_t TradeDate {65535UL};
		std::uint16_t ExpireDate {65535UL};
		IL3Enum::OrdStatusTrd OrdStatus;
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::BooleanFlag AggressorIndicator;
		std::uint8_t CrossType {255UL};
		std::uint8_t TotalNumSecurities;
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportTradeSpreadMsgOut: public ExecutionReportTradeSpreadMsg {
public:
	inline static const std::size_t blockLength {230};
	//static_assert (ExecutionReportTradeSpreadMsgOut::blockLength==sizeof (ExecutionReportTradeSpreadMsgOut::BlockData));

	ExecutionReportTradeSpreadMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by the exchange; unique per day across all instruments and across all good till orders
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Unique identifier that allows linking id spread summary fill notice with leg fill notice and trade cancel messages
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Number of shares or contracts ordered.
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Quantity of shares bought/sold on this (last) fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//Market Data Trade Entry ID. This identifier is assigned to all trades that take place for an instrument at a particular price level
	void setMDTradeEntryID (std::uint32_t v) { blockDataWrite_.MDTradeEntryID=v;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	void setSideTradeID (std::uint32_t v) { blockDataWrite_.SideTradeID=v;}

	//Quantity open for further execution;  LeavesQty = OrderQty (38) - CumQty (14); Only present for outrights and spreads and not spread legs
	void setLeavesQty (std::uint32_t v) { blockDataWrite_.LeavesQty=v;}

	//Indicates date of trading day (expressed in local time at place of trade).
	void setTradeDate (std::uint16_t v) { blockDataWrite_.TradeDate=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Identifies status of order as partially filled or completely filled
	void setOrdStatus (IL3Enum::OrdStatusTrd v) { blockDataWrite_.OrdStatus=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if order was sent manually or generated by automated trading logic
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates if order was incoming or resting for the match event
	void setAggressorIndicator (IL3Enum::BooleanFlag v) { blockDataWrite_.AggressorIndicator=v;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Indicates total number of leg fills for the spread; Will represent total number of ExecutionReportTradeSpreadLeg messages sent for the spread and will be set to 0 when spread leg fills are consolidated with spread fill
	void setTotalNumSecurities (std::uint8_t v) { blockDataWrite_.TotalNumSecurities=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportTradeSpreadLegMsg {
public:
	inline static const std::size_t id{527};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by the exchange; unique per day across all instruments and across all good till orders.
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Unique identifier that allows linking id spread summary fill notice with leg fill notice and trade cancel messages
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Quantity of shares bought/sold on this (last) fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	[[nodiscard]] std::uint32_t getSideTradeID () const { return blockData_->SideTradeID;}

	//Indicates date of trading day (expressed in local time at place of trade)
	[[nodiscard]] std::uint16_t getTradeDate () const { return blockData_->TradeDate;}

	//Identifies status of order as partially filled or completely filled
	[[nodiscard]] IL3Enum::OrdStatusTrd getOrdStatus () const { return blockData_->OrdStatus;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t SecExecID;
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t LastQty;
		std::uint32_t CumQty;
		std::uint32_t SideTradeID;
		std::uint16_t TradeDate {65535UL};
		IL3Enum::OrdStatusTrd OrdStatus;
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::BooleanFlag PossRetransFlag;
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportTradeSpreadLegMsgOut: public ExecutionReportTradeSpreadLegMsg {
public:
	inline static const std::size_t blockLength {199};
	//static_assert (ExecutionReportTradeSpreadLegMsgOut::blockLength==sizeof (ExecutionReportTradeSpreadLegMsgOut::BlockData));

	ExecutionReportTradeSpreadLegMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by the exchange; unique per day across all instruments and across all good till orders.
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments.
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Unique identifier that allows linking id spread summary fill notice with leg fill notice and trade cancel messages
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Quantity of shares bought/sold on this (last) fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	void setSideTradeID (std::uint32_t v) { blockDataWrite_.SideTradeID=v;}

	//Indicates date of trading day (expressed in local time at place of trade)
	void setTradeDate (std::uint16_t v) { blockDataWrite_.TradeDate=v;}

	//Identifies status of order as partially filled or completely filled
	void setOrdStatus (IL3Enum::OrdStatusTrd v) { blockDataWrite_.OrdStatus=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class QuoteCancelMsg {
public:
	inline static const std::size_t id{528};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Identifier of the Quote Cancel message. Should be unique per trading session. Uniqueness will not be enforced by CME and is incumbent on the market participant to maintain uniqueness
	[[nodiscard]] std::uint32_t getQuoteID () const { return blockData_->QuoteID;}

	//Identifies the type of Quote Cancel. A working quote can be cancelled by providing either it's instrument, instrument group or by cancelling all.
	[[nodiscard]] IL3Enum::QuoteCxlTyp getQuoteCancelType () const { return blockData_->QuoteCancelType;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SendingTimeEpoch;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::array<char, 5> Location;
		std::uint32_t QuoteID;
		IL3Enum::QuoteCxlTyp QuoteCancelType;
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
	};

	const BlockData *blockData_{nullptr};
};


class QuoteCancelMsgOut: public QuoteCancelMsg {
public:
	inline static const std::size_t blockLength {52};
	//static_assert (QuoteCancelMsgOut::blockLength==sizeof (QuoteCancelMsgOut::BlockData));

	QuoteCancelMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Identifier of the Quote Cancel message. Should be unique per trading session. Uniqueness will not be enforced by CME and is incumbent on the market participant to maintain uniqueness
	void setQuoteID (std::uint32_t v) { blockDataWrite_.QuoteID=v;}

	//Identifies the type of Quote Cancel. A working quote can be cancelled by providing either it's instrument, instrument group or by cancelling all.
	void setQuoteCancelType (IL3Enum::QuoteCxlTyp v) { blockDataWrite_.QuoteCancelType=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderMassActionRequestMsg {
public:
	inline static const std::size_t id{529};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the OrderMassActionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Specifies the Product Group for which working orders should be cancelled. Conditionally required if MassActionScope=?Product Group? (Tag1374=10). Will be ignored if present for any other criteria specified in MassActionScope besides Product Group 
	[[nodiscard]] std::string_view getSecurityGroup () const { return std::string_view(&blockData_->SecurityGroup[0], 6);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Conditionally required if MassActionScope=?Instrument? (Tag 1374=1). Will be ignored if present for any other criteria specified in MassActionScope besides Instrument
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Specifies the scope of the action   
	[[nodiscard]] IL3Enum::MassActionScope getMassActionScope () const { return blockData_->MassActionScope;}

	//Specifies the market segment (physical match engine partition) for which working orders should be cancelled. Conditionally Required if MassActionScope=?Market Segment? (Tag 1374=9). Will be ignored if present for any other criteria specified in MassActionScope besides Market Segment
	[[nodiscard]] std::uint8_t getMarketSegmentID () const { return blockData_->MarketSegmentID;}

	//If present ? specifies the scope of the OrderMassActionRequest within the context of Session and Firm. If absent then all orders belonging to Session and Firm combination will be cancelled for specified MassActionScope   
	[[nodiscard]] IL3Enum::MassCxlReqTyp getMassCancelRequestType () const { return blockData_->MassCancelRequestType;}

	//If provided then only orders belonging to one side will be cancelled. If absent then orders belonging to both sides will be cancelled
	[[nodiscard]] IL3Enum::SideNULL getSide () const { return blockData_->Side;}

	//If provided then only orders of this type will be cancelled. If absent then all order types will be cancelled
	[[nodiscard]] IL3Enum::MassActionOrdTyp getOrdType () const { return blockData_->OrdType;}

	//If provided then only orders with this qualifier will be cancelled. If absent then all Day & GT orders will be cancelled
	[[nodiscard]] IL3Enum::MassCancelTIF getTimeInForce () const { return blockData_->TimeInForce;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderRequestID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 6> SecurityGroup;
		std::array<char, 5> Location;
		std::int32_t SecurityID {2147483647};
		IL3Enum::MassActionScope MassActionScope;
		std::uint8_t MarketSegmentID {255UL};
		IL3Enum::MassCxlReqTyp MassCancelRequestType {IL3Enum::MassCxlReqTyp::Null};
		IL3Enum::SideNULL Side {IL3Enum::SideNULL::Null};
		IL3Enum::MassActionOrdTyp OrdType {IL3Enum::MassActionOrdTyp::Null};
		IL3Enum::MassCancelTIF TimeInForce {IL3Enum::MassCancelTIF::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
	};

	const BlockData *blockData_{nullptr};
};


class OrderMassActionRequestMsgOut: public OrderMassActionRequestMsg {
public:
	inline static const std::size_t blockLength {71};
	//static_assert (OrderMassActionRequestMsgOut::blockLength==sizeof (OrderMassActionRequestMsgOut::BlockData));

	OrderMassActionRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the OrderMassActionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Specifies the Product Group for which working orders should be cancelled. Conditionally required if MassActionScope=?Product Group? (Tag1374=10). Will be ignored if present for any other criteria specified in MassActionScope besides Product Group 
	void setSecurityGroup (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Conditionally required if MassActionScope=?Instrument? (Tag 1374=1). Will be ignored if present for any other criteria specified in MassActionScope besides Instrument
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Specifies the scope of the action   
	void setMassActionScope (IL3Enum::MassActionScope v) { blockDataWrite_.MassActionScope=v;}

	//Specifies the market segment (physical match engine partition) for which working orders should be cancelled. Conditionally Required if MassActionScope=?Market Segment? (Tag 1374=9). Will be ignored if present for any other criteria specified in MassActionScope besides Market Segment
	void setMarketSegmentID (std::uint8_t v) { blockDataWrite_.MarketSegmentID=v;}

	//If present ? specifies the scope of the OrderMassActionRequest within the context of Session and Firm. If absent then all orders belonging to Session and Firm combination will be cancelled for specified MassActionScope   
	void setMassCancelRequestType (IL3Enum::MassCxlReqTyp v) { blockDataWrite_.MassCancelRequestType=v;}

	//If provided then only orders belonging to one side will be cancelled. If absent then orders belonging to both sides will be cancelled
	void setSide (IL3Enum::SideNULL v) { blockDataWrite_.Side=v;}

	//If provided then only orders of this type will be cancelled. If absent then all order types will be cancelled
	void setOrdType (IL3Enum::MassActionOrdTyp v) { blockDataWrite_.OrdType=v;}

	//If provided then only orders with this qualifier will be cancelled. If absent then all Day & GT orders will be cancelled
	void setTimeInForce (IL3Enum::MassCancelTIF v) { blockDataWrite_.TimeInForce=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderMassStatusRequestMsg {
public:
	inline static const std::size_t id{530};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique ID of OrderMassStatusRequest as assigned by the customer and present in Execution Report as well
	[[nodiscard]] std::uint64_t getMassStatusReqID () const { return blockData_->MassStatusReqID;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Conditionally required if OrderStatusRequestType=?Product Group? (Tag 585=3). Status for working orders belonging to this particular product group will be returned. Will be ignored if present for any other criteria specified in OrderStatusRequestType besides product group (Tag 585=3) 
	[[nodiscard]] std::string_view getSecurityGroup () const { return std::string_view(&blockData_->SecurityGroup[0], 6);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Conditionally required if OrderStatusRequestType=?Instrument? (Tag 585=1). Status for working orders belonging to this particular instrument will be returned. Will be ignored if present for any other criteria specified in OrderStatusRequestType besides Instrument
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Specifies the scope of the OrderMassStatusRequest within the context of working orders only. Status will be returned for all orders matching the criteria specified here for Session and Firm
	[[nodiscard]] IL3Enum::MassStatusReqTyp getMassStatusReqType () const { return blockData_->MassStatusReqType;}

	//If present ? specifies the scope of the OrderMassStatusRequest within the context of MassStatusRequestType (585) and Session and Firm for working orders only. Status will be returned for all orders matching the criteria specified here for Session and Firm combination
	[[nodiscard]] IL3Enum::MassStatusOrdTyp getOrdStatusReqType () const { return blockData_->OrdStatusReqType;}

	//Specifies the scope of the OrderMassStatusRequest within the context of MassStatusRequestType (585) if present. Absence of this field is interpreted as Day & GTC & GTD. FAK is excluded since scope is limited to working orders only
	[[nodiscard]] IL3Enum::MassStatusTIF getTimeInForce () const { return blockData_->TimeInForce;}

	//Conditionally required if OrderStatusRequestType=?Market Segment? (Tag 585=100). Status for working orders belonging to this particular market segment will be returned. Will be ignored if present for any other criteria specified in OrderStatusRequestType besides market segment (Tag 585=100)
	[[nodiscard]] std::uint8_t getMarketSegmentID () const { return blockData_->MarketSegmentID;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t MassStatusReqID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 6> SecurityGroup;
		std::array<char, 5> Location;
		std::int32_t SecurityID {2147483647};
		IL3Enum::MassStatusReqTyp MassStatusReqType;
		IL3Enum::MassStatusOrdTyp OrdStatusReqType {IL3Enum::MassStatusOrdTyp::Null};
		IL3Enum::MassStatusTIF TimeInForce {IL3Enum::MassStatusTIF::Null};
		std::uint8_t MarketSegmentID {255UL};
	};

	const BlockData *blockData_{nullptr};
};


class OrderMassStatusRequestMsgOut: public OrderMassStatusRequestMsg {
public:
	inline static const std::size_t blockLength {68};
	//static_assert (OrderMassStatusRequestMsgOut::blockLength==sizeof (OrderMassStatusRequestMsgOut::BlockData));

	OrderMassStatusRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique ID of OrderMassStatusRequest as assigned by the customer and present in Execution Report as well
	void setMassStatusReqID (std::uint64_t v) { blockDataWrite_.MassStatusReqID=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Conditionally required if OrderStatusRequestType=?Product Group? (Tag 585=3). Status for working orders belonging to this particular product group will be returned. Will be ignored if present for any other criteria specified in OrderStatusRequestType besides product group (Tag 585=3) 
	void setSecurityGroup (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Conditionally required if OrderStatusRequestType=?Instrument? (Tag 585=1). Status for working orders belonging to this particular instrument will be returned. Will be ignored if present for any other criteria specified in OrderStatusRequestType besides Instrument
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Specifies the scope of the OrderMassStatusRequest within the context of working orders only. Status will be returned for all orders matching the criteria specified here for Session and Firm
	void setMassStatusReqType (IL3Enum::MassStatusReqTyp v) { blockDataWrite_.MassStatusReqType=v;}

	//If present ? specifies the scope of the OrderMassStatusRequest within the context of MassStatusRequestType (585) and Session and Firm for working orders only. Status will be returned for all orders matching the criteria specified here for Session and Firm combination
	void setOrdStatusReqType (IL3Enum::MassStatusOrdTyp v) { blockDataWrite_.OrdStatusReqType=v;}

	//Specifies the scope of the OrderMassStatusRequest within the context of MassStatusRequestType (585) if present. Absence of this field is interpreted as Day & GTC & GTD. FAK is excluded since scope is limited to working orders only
	void setTimeInForce (IL3Enum::MassStatusTIF v) { blockDataWrite_.TimeInForce=v;}

	//Conditionally required if OrderStatusRequestType=?Market Segment? (Tag 585=100). Status for working orders belonging to this particular market segment will be returned. Will be ignored if present for any other criteria specified in OrderStatusRequestType besides market segment (Tag 585=100)
	void setMarketSegmentID (std::uint8_t v) { blockDataWrite_.MarketSegmentID=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportModifyMsg {
public:
	inline static const std::size_t id{531};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Number of shares or contracts ordered.
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//Quantity open for further execution; LeavesQty = OrderQty (38) - CumQty (14)
	[[nodiscard]] std::uint32_t getLeavesQty () const { return blockData_->LeavesQty;}

	//Minimum quantity of an order to be executed.
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Order type
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if order was sent manually or generated by automated trading logic
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Type of cross being submitted to a market. (if in response to a cross order).
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t CumQty;
		std::uint32_t LeavesQty;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportModifyMsgOut: public ExecutionReportModifyMsg {
public:
	inline static const std::size_t blockLength {217};
	//static_assert (ExecutionReportModifyMsgOut::blockLength==sizeof (ExecutionReportModifyMsgOut::BlockData));

	ExecutionReportModifyMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Number of shares or contracts ordered.
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//Quantity open for further execution; LeavesQty = OrderQty (38) - CumQty (14)
	void setLeavesQty (std::uint32_t v) { blockDataWrite_.LeavesQty=v;}

	//Minimum quantity of an order to be executed.
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Order type
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if order was sent manually or generated by automated trading logic
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Type of cross being submitted to a market. (if in response to a cross order).
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportStatusMsg {
public:
	inline static const std::size_t id{532};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details; Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Used to uniquely identify a specific Order Status Request message
	[[nodiscard]] std::uint64_t getOrdStatusReqID () const { return blockData_->OrdStatusReqID;}

	//Unique ID of Order Mass Status Request as assigned by the client system 
	[[nodiscard]] std::uint64_t getMassStatusReqID () const { return blockData_->MassStatusReqID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides + strategy + legs. The HostCrossID will also be used to link together components of the cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Number of shares or contracts ordered.
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//Quantity open for further execution; LeavesQty = OrderQty (38) - CumQty (14)
	[[nodiscard]] std::uint32_t getLeavesQty () const { return blockData_->LeavesQty;}

	//Minimum quantity of an order to be executed.
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Identifies status of order
	[[nodiscard]] IL3Enum::OrderStatus getOrdStatus () const { return blockData_->OrdStatus;}

	//Order type
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether this message is the last report message in response to an Order Mass Status Request. Required if responding to a Order Mass Status Request.
	[[nodiscard]] IL3Enum::BooleanNULL getLastRptRequested () const { return blockData_->LastRptRequested;}

	//Type of cross being submitted to a market. (if in response to a cross order)
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t OrdStatusReqID {18446744073709551615UL};
		std::uint64_t MassStatusReqID {18446744073709551615UL};
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t CumQty;
		std::uint32_t LeavesQty;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		IL3Enum::OrderStatus OrdStatus;
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::BooleanNULL LastRptRequested {IL3Enum::BooleanNULL::Null};
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportStatusMsgOut: public ExecutionReportStatusMsg {
public:
	inline static const std::size_t blockLength {480};
	//static_assert (ExecutionReportStatusMsgOut::blockLength==sizeof (ExecutionReportStatusMsgOut::BlockData));

	ExecutionReportStatusMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details; Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Used to uniquely identify a specific Order Status Request message
	void setOrdStatusReqID (std::uint64_t v) { blockDataWrite_.OrdStatusReqID=v;}

	//Unique ID of Order Mass Status Request as assigned by the client system 
	void setMassStatusReqID (std::uint64_t v) { blockDataWrite_.MassStatusReqID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides + strategy + legs. The HostCrossID will also be used to link together components of the cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Number of shares or contracts ordered.
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//Quantity open for further execution; LeavesQty = OrderQty (38) - CumQty (14)
	void setLeavesQty (std::uint32_t v) { blockDataWrite_.LeavesQty=v;}

	//Minimum quantity of an order to be executed.
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Identifies status of order
	void setOrdStatus (IL3Enum::OrderStatus v) { blockDataWrite_.OrdStatus=v;}

	//Order type
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether this message is the last report message in response to an Order Mass Status Request. Required if responding to a Order Mass Status Request.
	void setLastRptRequested (IL3Enum::BooleanNULL v) { blockDataWrite_.LastRptRequested=v;}

	//Type of cross being submitted to a market. (if in response to a cross order)
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderStatusRequestMsg {
public:
	inline static const std::size_t id{533};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Used to uniquely identify a specific Order Status Request message. Echoed back on Execution Report as well
	[[nodiscard]] std::uint64_t getOrdStatusReqID () const { return blockData_->OrdStatusReqID;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrdStatusReqID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t OrderID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
	};

	const BlockData *blockData_{nullptr};
};


class OrderStatusRequestMsgOut: public OrderStatusRequestMsg {
public:
	inline static const std::size_t blockLength {62};
	//static_assert (OrderStatusRequestMsgOut::blockLength==sizeof (OrderStatusRequestMsgOut::BlockData));

	OrderStatusRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Used to uniquely identify a specific Order Status Request message. Echoed back on Execution Report as well
	void setOrdStatusReqID (std::uint64_t v) { blockDataWrite_.OrdStatusReqID=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportCancelMsg {
public:
	inline static const std::size_t id{534};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	[[nodiscard]] std::uint64_t getHostCrossID () const { return blockData_->HostCrossID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Number of shares or contracts ordered.
	[[nodiscard]] std::uint32_t getOrderQty () const { return blockData_->OrderQty;}

	//Total quantity filled
	[[nodiscard]] std::uint32_t getCumQty () const { return blockData_->CumQty;}

	//Minimum quantity of an order to be executed.
	[[nodiscard]] std::uint32_t getMinQty () const { return blockData_->MinQty;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	[[nodiscard]] std::uint32_t getDisplayQty () const { return blockData_->DisplayQty;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	[[nodiscard]] std::uint16_t getExpireDate () const { return blockData_->ExpireDate;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Side of order
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Specifies how long the order remains in effect
	[[nodiscard]] IL3Enum::TimeInForce getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Used to communicate unsolicited cancels
	[[nodiscard]] IL3Enum::ExecReason getExecRestatementReason () const { return blockData_->ExecRestatementReason;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	[[nodiscard]] std::uint8_t getCrossType () const { return blockData_->CrossType;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t CrossID {18446744073709551615UL};
		std::uint64_t HostCrossID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t OrderQty;
		std::uint32_t CumQty;
		std::uint32_t MinQty {4294967295UL};
		std::uint32_t DisplayQty {4294967295UL};
		std::uint16_t ExpireDate {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::TimeInForce TimeInForce;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::ExecReason ExecRestatementReason {IL3Enum::ExecReason::Null};
		std::uint8_t CrossType {255UL};
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportCancelMsgOut: public ExecutionReportCancelMsg {
public:
	inline static const std::size_t blockLength {214};
	//static_assert (ExecutionReportCancelMsgOut::blockLength==sizeof (ExecutionReportCancelMsgOut::BlockData));

	ExecutionReportCancelMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Identifier for a cross order. Will be present if execution report is in response to a cross order
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Host assigned entity ID that can be used to reference all components of a cross; sides +  strategy + legs. The HostCrossID will also be used to link together components of the  cross order. For example, each individual execution report associated with the order will carry HostCrossID in order to tie them back together to the original cross order.
	void setHostCrossID (std::uint64_t v) { blockDataWrite_.HostCrossID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Number of shares or contracts ordered.
	void setOrderQty (std::uint32_t v) { blockDataWrite_.OrderQty=v;}

	//Total quantity filled
	void setCumQty (std::uint32_t v) { blockDataWrite_.CumQty=v;}

	//Minimum quantity of an order to be executed.
	void setMinQty (std::uint32_t v) { blockDataWrite_.MinQty=v;}

	//The quantity to be displayed . Required for iceberg orders. On orders specifies the qty to be displayed, on execution reports the currently displayed quantity
	void setDisplayQty (std::uint32_t v) { blockDataWrite_.DisplayQty=v;}

	//Date of order expiration (last day the order can trade), always expressed in terms of the local market date
	void setExpireDate (std::uint16_t v) { blockDataWrite_.ExpireDate=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Side of order
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Specifies how long the order remains in effect
	void setTimeInForce (IL3Enum::TimeInForce v) { blockDataWrite_.TimeInForce=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Used to communicate unsolicited cancels
	void setExecRestatementReason (IL3Enum::ExecReason v) { blockDataWrite_.ExecRestatementReason=v;}

	//Type of cross being submitted to a market. (if in response to a cross order) 
	void setCrossType (std::uint8_t v) { blockDataWrite_.CrossType=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered); default behavior when absent is aggressive
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//New field added to capture if an order was submitted for market making obligation or not. Applicable only for EU fixed income markets
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderCancelRejectMsg {
public:
	inline static const std::size_t id{535};

	//Sequence number of this message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details; Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this OrderCancelReject (35=9) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the OrderCancelReject representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Code to identify reason for cancel rejection
	[[nodiscard]] std::uint16_t getCxlRejReason () const { return blockData_->CxlRejReason;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::array<char, 5> Location;
		std::uint16_t CxlRejReason;
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class OrderCancelRejectMsgOut: public OrderCancelRejectMsg {
public:
	inline static const std::size_t blockLength {409};
	//static_assert (OrderCancelRejectMsgOut::blockLength==sizeof (OrderCancelRejectMsgOut::BlockData));

	OrderCancelRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number of this message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details; Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this OrderCancelReject (35=9) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the OrderCancelReject representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Code to identify reason for cancel rejection
	void setCxlRejReason (std::uint16_t v) { blockDataWrite_.CxlRejReason=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderCancelReplaceRejectMsg {
public:
	inline static const std::size_t id{536};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details; Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this OrderCancelReplaceReject (35=9) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the OrderCancelReplaceReject representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Code to identify reason for cancel replace rejection
	[[nodiscard]] std::uint16_t getCxlRejReason () const { return blockData_->CxlRejReason;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::array<char, 5> Location;
		std::uint16_t CxlRejReason;
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class OrderCancelReplaceRejectMsgOut: public OrderCancelReplaceRejectMsg {
public:
	inline static const std::size_t blockLength {409};
	//static_assert (OrderCancelReplaceRejectMsgOut::blockLength==sizeof (OrderCancelReplaceRejectMsgOut::BlockData));

	OrderCancelReplaceRejectMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details; Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this OrderCancelReplaceReject (35=9) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the OrderCancelReplaceReject representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Code to identify reason for cancel replace rejection
	void setCxlRejReason (std::uint16_t v) { blockDataWrite_.CxlRejReason=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class PartyDetailsListRequestMsg {
public:
	inline static const std::size_t id{537};

	//The unique identifier of the PartyDetailsListRequest(35=CF) message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SendingTimeEpoch;
		std::uint32_t SeqNum;
	};

	const BlockData *blockData_{nullptr};
};


class PartyDetailsListRequestMsgOut: public PartyDetailsListRequestMsg {
public:
	inline static const std::size_t blockLength {20};
	//static_assert (PartyDetailsListRequestMsgOut::blockLength==sizeof (PartyDetailsListRequestMsgOut::BlockData));

	PartyDetailsListRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//The unique identifier of the PartyDetailsListRequest(35=CF) message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class PartyDetailsListReportMsg {
public:
	inline static const std::size_t id{538};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Used by submitting firm to group trades being allocated into an average price group; The trades in average price group will be used to calculate an average price for the group
	[[nodiscard]] std::string_view getAvgPxGroupID () const { return std::string_view(&blockData_->AvgPxGroupID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequest(35=CX) message used to create the PartyDetailsDefinition
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Refers to the unique identifier of the PartyDetailsListRequest(35=CF) message used to request this PartyDetailsListReport
	[[nodiscard]] std::uint64_t getPartyDetailsListReportID () const { return blockData_->PartyDetailsListReportID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Identifies an order or trade that should not be matched to an opposite order or trade if both buy and sell orders for the same asset contain the same SelfMatchPreventionID (2362) and submitted by the same firm
	[[nodiscard]] std::uint64_t getSelfMatchPreventionID () const { return blockData_->SelfMatchPreventionID;}

	//Indicates total number of PartyDetailsListReports being returned in response to PartyDetailsListRequest
	[[nodiscard]] std::uint16_t getTotNumParties () const { return blockData_->TotNumParties;}

	//Status of party details list request
	[[nodiscard]] IL3Enum::ReqResult getRequestResult () const { return blockData_->RequestResult;}

	//Indicates whether the message is the last message in a sequence of messages to support fragmentation
	[[nodiscard]] IL3Enum::BooleanFlag getLastFragment () const { return blockData_->LastFragment;}

	//Capacity of customer placing the order; Used by futures exchanges to indicate the CTICode (customer type indicator) as required by the US CFTC (Commodity Futures Trading Commission)
	[[nodiscard]] IL3Enum::CustOrderCapacity getCustOrderCapacity () const { return blockData_->CustOrderCapacity;}

	//Designates the account type to be used for the order when submitted to clearing
	[[nodiscard]] IL3Enum::ClearingAcctType getClearingAccountType () const { return blockData_->ClearingAccountType;}

	//Used to act upon the outcome when a self-match is detected and an order is prevented from trading against another order with the same SelfMatchPreventionID (Tag 2362), N=Cancel newest signifies that incoming order is cancelled, O=Cancel Oldest signifies that the resting order is cancelled. Absence of this field (with Tag 2362) is interpreted as cancel oldest
	[[nodiscard]] IL3Enum::SMPI getSelfMatchPreventionInstruction () const { return blockData_->SelfMatchPreventionInstruction;}

	//Average pricing indicator
	[[nodiscard]] IL3Enum::AvgPxInd getAvgPxIndicator () const { return blockData_->AvgPxIndicator;}

	//Indicates to recipient whether trade is clearing at execution prices LastPx (tag 31) or alternate clearing price (prior day settlement price)
	[[nodiscard]] IL3Enum::SLEDS getClearingTradePriceType () const { return blockData_->ClearingTradePriceType;}

	//Indicates if the order is a give-up or SGX offset
	[[nodiscard]] IL3Enum::CmtaGiveUpCD getCmtaGiveupCD () const { return blockData_->CmtaGiveupCD;}

	//Codes that apply special information that the Broker / Dealer needs to report, as specified by the customer. Defines source of the order
	[[nodiscard]] IL3Enum::CustOrdHandlInst getCustOrderHandlingInst () const { return blockData_->CustOrderHandlingInst;}

	//Will be populated with a short code for the person or algo identified in FIX tag 5392 which will be mapped to National ID or Algo at reporting time
	[[nodiscard]] std::uint64_t getExecutor () const { return blockData_->Executor;}

	//Represents the Investment Decision Maker Short Code
	[[nodiscard]] std::uint64_t getIDMShortCode () const { return blockData_->IDMShortCode;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 20> AvgPxGroupID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t PartyDetailsListReportID;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t SelfMatchPreventionID {18446744073709551615UL};
		std::uint16_t TotNumParties;
		IL3Enum::ReqResult RequestResult;
		IL3Enum::BooleanFlag LastFragment;
		IL3Enum::CustOrderCapacity CustOrderCapacity {IL3Enum::CustOrderCapacity::Null};
		IL3Enum::ClearingAcctType ClearingAccountType {IL3Enum::ClearingAcctType::Null};
		IL3Enum::SMPI SelfMatchPreventionInstruction {IL3Enum::SMPI::Null};
		IL3Enum::AvgPxInd AvgPxIndicator {IL3Enum::AvgPxInd::Null};
		IL3Enum::SLEDS ClearingTradePriceType {IL3Enum::SLEDS::Null};
		IL3Enum::CmtaGiveUpCD CmtaGiveupCD {IL3Enum::CmtaGiveUpCD::Null};
		IL3Enum::CustOrdHandlInst CustOrderHandlingInst {IL3Enum::CustOrdHandlInst::Null};
		std::uint64_t Executor {18446744073709551615UL};
		std::uint64_t IDMShortCode {18446744073709551615UL};
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
	};

	const BlockData *blockData_{nullptr};
};


class PartyDetailsListReportMsgOut: public PartyDetailsListReportMsg {
public:
	inline static const std::size_t blockLength {93};
	//static_assert (PartyDetailsListReportMsgOut::blockLength==sizeof (PartyDetailsListReportMsgOut::BlockData));

	PartyDetailsListReportMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Used by submitting firm to group trades being allocated into an average price group; The trades in average price group will be used to calculate an average price for the group
	void setAvgPxGroupID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequest(35=CX) message used to create the PartyDetailsDefinition
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Refers to the unique identifier of the PartyDetailsListRequest(35=CF) message used to request this PartyDetailsListReport
	void setPartyDetailsListReportID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReportID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Identifies an order or trade that should not be matched to an opposite order or trade if both buy and sell orders for the same asset contain the same SelfMatchPreventionID (2362) and submitted by the same firm
	void setSelfMatchPreventionID (std::uint64_t v) { blockDataWrite_.SelfMatchPreventionID=v;}

	//Indicates total number of PartyDetailsListReports being returned in response to PartyDetailsListRequest
	void setTotNumParties (std::uint16_t v) { blockDataWrite_.TotNumParties=v;}

	//Status of party details list request
	void setRequestResult (IL3Enum::ReqResult v) { blockDataWrite_.RequestResult=v;}

	//Indicates whether the message is the last message in a sequence of messages to support fragmentation
	void setLastFragment (IL3Enum::BooleanFlag v) { blockDataWrite_.LastFragment=v;}

	//Capacity of customer placing the order; Used by futures exchanges to indicate the CTICode (customer type indicator) as required by the US CFTC (Commodity Futures Trading Commission)
	void setCustOrderCapacity (IL3Enum::CustOrderCapacity v) { blockDataWrite_.CustOrderCapacity=v;}

	//Designates the account type to be used for the order when submitted to clearing
	void setClearingAccountType (IL3Enum::ClearingAcctType v) { blockDataWrite_.ClearingAccountType=v;}

	//Used to act upon the outcome when a self-match is detected and an order is prevented from trading against another order with the same SelfMatchPreventionID (Tag 2362), N=Cancel newest signifies that incoming order is cancelled, O=Cancel Oldest signifies that the resting order is cancelled. Absence of this field (with Tag 2362) is interpreted as cancel oldest
	void setSelfMatchPreventionInstruction (IL3Enum::SMPI v) { blockDataWrite_.SelfMatchPreventionInstruction=v;}

	//Average pricing indicator
	void setAvgPxIndicator (IL3Enum::AvgPxInd v) { blockDataWrite_.AvgPxIndicator=v;}

	//Indicates to recipient whether trade is clearing at execution prices LastPx (tag 31) or alternate clearing price (prior day settlement price)
	void setClearingTradePriceType (IL3Enum::SLEDS v) { blockDataWrite_.ClearingTradePriceType=v;}

	//Indicates if the order is a give-up or SGX offset
	void setCmtaGiveupCD (IL3Enum::CmtaGiveUpCD v) { blockDataWrite_.CmtaGiveupCD=v;}

	//Codes that apply special information that the Broker / Dealer needs to report, as specified by the customer. Defines source of the order
	void setCustOrderHandlingInst (IL3Enum::CustOrdHandlInst v) { blockDataWrite_.CustOrderHandlingInst=v;}

	//Will be populated with a short code for the person or algo identified in FIX tag 5392 which will be mapped to National ID or Algo at reporting time
	void setExecutor (std::uint64_t v) { blockDataWrite_.Executor=v;}

	//Represents the Investment Decision Maker Short Code
	void setIDMShortCode (std::uint64_t v) { blockDataWrite_.IDMShortCode=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionAckMsg {
public:
	inline static const std::size_t id{539};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Order ID of the problem execution
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Indicates the status of the execution acknowledgement
	[[nodiscard]] IL3Enum::ExecAckStatus getExecAckStatus () const { return blockData_->ExecAckStatus;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//CIOrdID of the problem execution
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//The binary trade number (Tag 1797) being accepted or rejected from the original fill 
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Quantity of shares bought/sold on this fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//Reason for execution rejection
	[[nodiscard]] IL3Enum::DKReason getDKReason () const { return blockData_->DKReason;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Indicates if the message was initially received manually (as opposed to electronically) 
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		IL3Enum::ExecAckStatus ExecAckStatus;
		std::uint32_t SeqNum;
		std::array<char, 20> ClOrdID;
		std::uint64_t SecExecID;
		std::int32_t SecurityID;
		std::uint32_t LastQty;
		IL3Enum::DKReason DKReason {IL3Enum::DKReason::Null};
		IL3Enum::SideReq Side;
		std::array<char, 20> SenderID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionAckMsgOut: public ExecutionAckMsg {
public:
	inline static const std::size_t blockLength {101};
	//static_assert (ExecutionAckMsgOut::blockLength==sizeof (ExecutionAckMsgOut::BlockData));

	ExecutionAckMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Order ID of the problem execution
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Indicates the status of the execution acknowledgement
	void setExecAckStatus (IL3Enum::ExecAckStatus v) { blockDataWrite_.ExecAckStatus=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//CIOrdID of the problem execution
	void setClOrdID (std::string_view v) { (void) v;}

	//The binary trade number (Tag 1797) being accepted or rejected from the original fill 
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Quantity of shares bought/sold on this fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//Reason for execution rejection
	void setDKReason (IL3Enum::DKReason v) { blockDataWrite_.DKReason=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Indicates if the message was initially received manually (as opposed to electronically) 
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class RequestForQuoteMsg {
public:
	inline static const std::size_t id{543};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for quote request message
	[[nodiscard]] std::uint64_t getQuoteReqID () const { return blockData_->QuoteReqID;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Type of quote requested 
	[[nodiscard]] IL3Enum::QuoteTyp getQuoteType () const { return blockData_->QuoteType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t QuoteReqID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
		IL3Enum::QuoteTyp QuoteType {IL3Enum::QuoteTyp::Null};
	};

	const BlockData *blockData_{nullptr};
};


class RequestForQuoteMsgOut: public RequestForQuoteMsg {
public:
	inline static const std::size_t blockLength {55};
	//static_assert (RequestForQuoteMsgOut::blockLength==sizeof (RequestForQuoteMsgOut::BlockData));

	RequestForQuoteMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for quote request message
	void setQuoteReqID (std::uint64_t v) { blockDataWrite_.QuoteReqID=v;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Type of quote requested 
	void setQuoteType (IL3Enum::QuoteTyp v) { blockDataWrite_.QuoteType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class NewOrderCrossMsg {
public:
	inline static const std::size_t id{544};

	//Identifier for a cross order. Must be unique during a given trading day
	[[nodiscard]] std::uint64_t getCrossID () const { return blockData_->CrossID;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//For derivatives a date and time stamp to indicate when this order was booked with the agent prior to submission to the exchange. Indicates the time at which the order was finalized between the buyer and seller prior to submission. Expressed as nanoseconds since epoch time 
	[[nodiscard]] std::uint64_t getTransBkdTime () const { return blockData_->TransBkdTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Instrument identifier
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t CrossID;
		std::uint64_t OrderRequestID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t TransBkdTime;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 5> Location;
		std::int32_t SecurityID;
	};

	const BlockData *blockData_{nullptr};
};


class NewOrderCrossMsgOut: public NewOrderCrossMsg {
public:
	inline static const std::size_t blockLength {74};
	//static_assert (NewOrderCrossMsgOut::blockLength==sizeof (NewOrderCrossMsgOut::BlockData));

	NewOrderCrossMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Identifier for a cross order. Must be unique during a given trading day
	void setCrossID (std::uint64_t v) { blockDataWrite_.CrossID=v;}

	//Use OrderRequestID to identify a request to enter, modify or delete an order and echo the value on the ExecutionReport representing the response
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//For derivatives a date and time stamp to indicate when this order was booked with the agent prior to submission to the exchange. Indicates the time at which the order was finalized between the buyer and seller prior to submission. Expressed as nanoseconds since epoch time 
	void setTransBkdTime (std::uint64_t v) { blockDataWrite_.TransBkdTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Instrument identifier
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class MassQuoteAckMsg {
public:
	inline static const std::size_t id{545};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details. Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Information carried on a response to convey the time (UTC) when the request was received by the MSGW application. UTC timestamps are sent in number of nanoseconds since the UNIX epoch with microsecond precision
	[[nodiscard]] std::uint64_t getRequestTime () const { return blockData_->RequestTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Conditionally present when MassQuote was sent in response to RequestForQuote
	[[nodiscard]] std::uint64_t getQuoteReqID () const { return blockData_->QuoteReqID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Unique identifier for mass quote populated by the client system
	[[nodiscard]] std::uint32_t getQuoteID () const { return blockData_->QuoteID;}

	//Contains reason (error code) the corresponding MassQuote message has been rejected. When this tag is returned, all quotes in the corresponding Mass Quote message are rejected.
	[[nodiscard]] std::uint16_t getQuoteRejectReason () const { return blockData_->QuoteRejectReason;}

	//Not being used currently
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Identifies the status of the quote acknowledgement.
	[[nodiscard]] IL3Enum::QuoteAckStatus getQuoteStatus () const { return blockData_->QuoteStatus;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Number of quotes that have been accepted from the corresponding inbound message
	[[nodiscard]] std::uint8_t getNoProcessedEntries () const { return blockData_->NoProcessedEntries;}

	//When market maker protection is triggered then Falcon will not accept any new quotes from the market maker for that product group until it receives a mass quote message with the MMProtectionReset flag set to Y
	[[nodiscard]] IL3Enum::BooleanFlag getMMProtectionReset () const { return blockData_->MMProtectionReset;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}

	//Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set. Required if NoQuoteEntries > 0. Since fragmentation is not supported in practice this will always be equal to the value of NoQuoteEntries.
	[[nodiscard]] std::uint8_t getTotNoQuoteEntries () const { return blockData_->TotNoQuoteEntries;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 20> SenderID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t RequestTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t QuoteReqID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::uint32_t QuoteID;
		std::uint16_t QuoteRejectReason {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::QuoteAckStatus QuoteStatus;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint8_t NoProcessedEntries;
		IL3Enum::BooleanFlag MMProtectionReset;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
		std::uint8_t TotNoQuoteEntries {255UL};
		IL3Enum::BooleanFlag PossRetransFlag;
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class MassQuoteAckMsgOut: public MassQuoteAckMsg {
public:
	inline static const std::size_t blockLength {350};
	//static_assert (MassQuoteAckMsgOut::blockLength==sizeof (MassQuoteAckMsgOut::BlockData));

	MassQuoteAckMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details. Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Information carried on a response to convey the time (UTC) when the request was received by the MSGW application. UTC timestamps are sent in number of nanoseconds since the UNIX epoch with microsecond precision
	void setRequestTime (std::uint64_t v) { blockDataWrite_.RequestTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Conditionally present when MassQuote was sent in response to RequestForQuote
	void setQuoteReqID (std::uint64_t v) { blockDataWrite_.QuoteReqID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Unique identifier for mass quote populated by the client system
	void setQuoteID (std::uint32_t v) { blockDataWrite_.QuoteID=v;}

	//Contains reason (error code) the corresponding MassQuote message has been rejected. When this tag is returned, all quotes in the corresponding Mass Quote message are rejected.
	void setQuoteRejectReason (std::uint16_t v) { blockDataWrite_.QuoteRejectReason=v;}

	//Not being used currently
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Identifies the status of the quote acknowledgement.
	void setQuoteStatus (IL3Enum::QuoteAckStatus v) { blockDataWrite_.QuoteStatus=v;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Number of quotes that have been accepted from the corresponding inbound message
	void setNoProcessedEntries (std::uint8_t v) { blockDataWrite_.NoProcessedEntries=v;}

	//When market maker protection is triggered then Falcon will not accept any new quotes from the market maker for that product group until it receives a mass quote message with the MMProtectionReset flag set to Y
	void setMMProtectionReset (IL3Enum::BooleanFlag v) { blockDataWrite_.MMProtectionReset=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	//Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set. Required if NoQuoteEntries > 0. Since fragmentation is not supported in practice this will always be equal to the value of NoQuoteEntries.
	void setTotNoQuoteEntries (std::uint8_t v) { blockDataWrite_.TotNoQuoteEntries=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class RequestForQuoteAckMsg {
public:
	inline static const std::size_t id{546};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details. Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//CME Globex generated QuoteID 
	[[nodiscard]] std::string_view getExchangeQuoteReqID () const { return std::string_view(&blockData_->ExchangeQuoteReqID[0], 17);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Information carried on a response to convey the time (UTC) when the request was received by the MSGW application. UTC timestamps are sent in number of nanoseconds since the UNIX epoch with microsecond precision
	[[nodiscard]] std::uint64_t getRequestTime () const { return blockData_->RequestTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Unique identifier for quote request message
	[[nodiscard]] std::uint64_t getQuoteReqID () const { return blockData_->QuoteReqID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Contains reason (error code) the corresponding RequestForQuote message has been rejected
	[[nodiscard]] std::uint16_t getQuoteRejectReason () const { return blockData_->QuoteRejectReason;}

	//Not being used currently
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Identifies the status of the quote acknowledgement.
	[[nodiscard]] IL3Enum::QuoteAckStatus getQuoteStatus () const { return blockData_->QuoteStatus;}

	//Indicates if the message was initially received manually (as opposed to electronically) 
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 20> SenderID;
		std::array<char, 17> ExchangeQuoteReqID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t RequestTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t QuoteReqID;
		std::array<char, 5> Location;
		std::uint16_t QuoteRejectReason {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::QuoteAckStatus QuoteStatus;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::BooleanFlag PossRetransFlag;
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class RequestForQuoteAckMsgOut: public RequestForQuoteAckMsg {
public:
	inline static const std::size_t blockLength {358};
	//static_assert (RequestForQuoteAckMsgOut::blockLength==sizeof (RequestForQuoteAckMsgOut::BlockData));

	RequestForQuoteAckMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details. Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//CME Globex generated QuoteID 
	void setExchangeQuoteReqID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Information carried on a response to convey the time (UTC) when the request was received by the MSGW application. UTC timestamps are sent in number of nanoseconds since the UNIX epoch with microsecond precision
	void setRequestTime (std::uint64_t v) { blockDataWrite_.RequestTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Unique identifier for quote request message
	void setQuoteReqID (std::uint64_t v) { blockDataWrite_.QuoteReqID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Contains reason (error code) the corresponding RequestForQuote message has been rejected
	void setQuoteRejectReason (std::uint16_t v) { blockDataWrite_.QuoteRejectReason=v;}

	//Not being used currently
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Identifies the status of the quote acknowledgement.
	void setQuoteStatus (IL3Enum::QuoteAckStatus v) { blockDataWrite_.QuoteStatus=v;}

	//Indicates if the message was initially received manually (as opposed to electronically) 
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportTradeAddendumOutrightMsg {
public:
	inline static const std::size_t id{548};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique Order ID
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Unique identifier that allows linking between spread summary fill notice with leg fill notice and trade cancel messages. Trade correction of previously executed trade will assign a new value
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Unique identifier of the fill which is being corrected
	[[nodiscard]] std::uint64_t getOrigSecondaryExecutionID () const { return blockData_->OrigSecondaryExecutionID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Quantity of shares bought/sold on this (last) fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	[[nodiscard]] std::uint32_t getSideTradeID () const { return blockData_->SideTradeID;}

	//Refers back to the unique ID assigned to the corrected trade
	[[nodiscard]] std::uint32_t getOrigSideTradeID () const { return blockData_->OrigSideTradeID;}

	//Indicates date of trading day (expressed in local time at place of trade).
	[[nodiscard]] std::uint16_t getTradeDate () const { return blockData_->TradeDate;}

	//Identifies status of order as trade cancellation or correction
	[[nodiscard]] IL3Enum::OrdStatusTrdCxl getOrdStatus () const { return blockData_->OrdStatus;}

	//Describes the specific ExecutionRpt as trade cancellation or correction
	[[nodiscard]] IL3Enum::ExecTypTrdCxl getExecType () const { return blockData_->ExecType;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered)
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//Represents the market making MiFID obligation reporting of the first order belonging to the trader in this event for whom the summary is being reported
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t SecExecID;
		std::uint64_t OrigSecondaryExecutionID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t LastQty;
		std::uint32_t SideTradeID;
		std::uint32_t OrigSideTradeID {4294967295UL};
		std::uint16_t TradeDate {65535UL};
		IL3Enum::OrdStatusTrdCxl OrdStatus;
		IL3Enum::ExecTypTrdCxl ExecType;
		IL3Enum::SideReq Side;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportTradeAddendumOutrightMsgOut: public ExecutionReportTradeAddendumOutrightMsg {
public:
	inline static const std::size_t blockLength {181};
	//static_assert (ExecutionReportTradeAddendumOutrightMsgOut::blockLength==sizeof (ExecutionReportTradeAddendumOutrightMsgOut::BlockData));

	ExecutionReportTradeAddendumOutrightMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique Order ID
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Unique identifier that allows linking between spread summary fill notice with leg fill notice and trade cancel messages. Trade correction of previously executed trade will assign a new value
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Unique identifier of the fill which is being corrected
	void setOrigSecondaryExecutionID (std::uint64_t v) { blockDataWrite_.OrigSecondaryExecutionID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages.
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Quantity of shares bought/sold on this (last) fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	void setSideTradeID (std::uint32_t v) { blockDataWrite_.SideTradeID=v;}

	//Refers back to the unique ID assigned to the corrected trade
	void setOrigSideTradeID (std::uint32_t v) { blockDataWrite_.OrigSideTradeID=v;}

	//Indicates date of trading day (expressed in local time at place of trade).
	void setTradeDate (std::uint16_t v) { blockDataWrite_.TradeDate=v;}

	//Identifies status of order as trade cancellation or correction
	void setOrdStatus (IL3Enum::OrdStatusTrdCxl v) { blockDataWrite_.OrdStatus=v;}

	//Describes the specific ExecutionRpt as trade cancellation or correction
	void setExecType (IL3Enum::ExecTypTrdCxl v) { blockDataWrite_.ExecType=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered)
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//Represents the market making MiFID obligation reporting of the first order belonging to the trader in this event for whom the summary is being reported
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportTradeAddendumSpreadMsg {
public:
	inline static const std::size_t id{549};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique Order ID
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Unique identifier that allows linking between spread summary fill notice with leg fill notice and trade cancel messages. Trade correction of previously executed trade will assign a new value
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Unique identifier of the fill which is being corrected
	[[nodiscard]] std::uint64_t getOrigSecondaryExecutionID () const { return blockData_->OrigSecondaryExecutionID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Unique instrument ID 
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Market Data Trade Entry ID
	[[nodiscard]] std::uint32_t getMDTradeEntryID () const { return blockData_->MDTradeEntryID;}

	//Quantity of shares bought/sold on this (last) fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//The unique ID assigned to the trade once it is received or matched by the exchange or subsequently corrected
	[[nodiscard]] std::uint32_t getSideTradeID () const { return blockData_->SideTradeID;}

	//Refers back to the unique ID assigned to the original trade being corrected
	[[nodiscard]] std::uint32_t getOrigSideTradeID () const { return blockData_->OrigSideTradeID;}

	//Indicates date of trading day (expressed in local time at place of trade).
	[[nodiscard]] std::uint16_t getTradeDate () const { return blockData_->TradeDate;}

	//Identifies status of order as trade cancellation or correction
	[[nodiscard]] IL3Enum::OrdStatusTrdCxl getOrdStatus () const { return blockData_->OrdStatus;}

	//Describes the action that triggered this specific Execution Report and see the OrdStatus (39) tag for the current order status (e.g.,Partially Filled).
	[[nodiscard]] IL3Enum::ExecTypTrdCxl getExecType () const { return blockData_->ExecType;}

	//Order type.
	[[nodiscard]] IL3Enum::OrderType getOrdType () const { return blockData_->OrdType;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}

	//Indicates if order was sent manually or generated by automated trading logic
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates total number of leg fills for the spread. Will represent total number of ExecutionReportTradeSpreadLeg messages sent for the spread and will be set to 0 when spread leg fills are consolidated with spread fill
	[[nodiscard]] std::uint8_t getTotalNumSecurities () const { return blockData_->TotalNumSecurities;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered)
	[[nodiscard]] IL3Enum::ExecMode getExecutionMode () const { return blockData_->ExecutionMode;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Boolean: flags a managed order
	[[nodiscard]] IL3Enum::BooleanNULL getManagedOrder () const { return blockData_->ManagedOrder;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	[[nodiscard]] IL3Enum::ShortSaleType getShortSaleType () const { return blockData_->ShortSaleType;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t SecExecID;
		std::uint64_t OrigSecondaryExecutionID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t MDTradeEntryID;
		std::uint32_t LastQty;
		std::uint32_t SideTradeID;
		std::uint32_t OrigSideTradeID {4294967295UL};
		std::uint16_t TradeDate {65535UL};
		IL3Enum::OrdStatusTrdCxl OrdStatus;
		IL3Enum::ExecTypTrdCxl ExecType;
		IL3Enum::OrderType OrdType;
		IL3Enum::SideReq Side;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		std::uint8_t TotalNumSecurities;
		IL3Enum::ExecMode ExecutionMode {IL3Enum::ExecMode::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanNULL ManagedOrder {IL3Enum::BooleanNULL::Null};
		IL3Enum::ShortSaleType ShortSaleType {IL3Enum::ShortSaleType::Null};
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportTradeAddendumSpreadMsgOut: public ExecutionReportTradeAddendumSpreadMsg {
public:
	inline static const std::size_t blockLength {187};
	//static_assert (ExecutionReportTradeAddendumSpreadMsgOut::blockLength==sizeof (ExecutionReportTradeAddendumSpreadMsgOut::BlockData));

	ExecutionReportTradeAddendumSpreadMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique Order ID
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Unique identifier that allows linking between spread summary fill notice with leg fill notice and trade cancel messages. Trade correction of previously executed trade will assign a new value
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Unique identifier of the fill which is being corrected
	void setOrigSecondaryExecutionID (std::uint64_t v) { blockDataWrite_.OrigSecondaryExecutionID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Unique instrument ID 
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Market Data Trade Entry ID
	void setMDTradeEntryID (std::uint32_t v) { blockDataWrite_.MDTradeEntryID=v;}

	//Quantity of shares bought/sold on this (last) fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//The unique ID assigned to the trade once it is received or matched by the exchange or subsequently corrected
	void setSideTradeID (std::uint32_t v) { blockDataWrite_.SideTradeID=v;}

	//Refers back to the unique ID assigned to the original trade being corrected
	void setOrigSideTradeID (std::uint32_t v) { blockDataWrite_.OrigSideTradeID=v;}

	//Indicates date of trading day (expressed in local time at place of trade).
	void setTradeDate (std::uint16_t v) { blockDataWrite_.TradeDate=v;}

	//Identifies status of order as trade cancellation or correction
	void setOrdStatus (IL3Enum::OrdStatusTrdCxl v) { blockDataWrite_.OrdStatus=v;}

	//Describes the action that triggered this specific Execution Report and see the OrdStatus (39) tag for the current order status (e.g.,Partially Filled).
	void setExecType (IL3Enum::ExecTypTrdCxl v) { blockDataWrite_.ExecType=v;}

	//Order type.
	void setOrdType (IL3Enum::OrderType v) { blockDataWrite_.OrdType=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	//Indicates if order was sent manually or generated by automated trading logic
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates total number of leg fills for the spread. Will represent total number of ExecutionReportTradeSpreadLeg messages sent for the spread and will be set to 0 when spread leg fills are consolidated with spread fill
	void setTotalNumSecurities (std::uint8_t v) { blockDataWrite_.TotalNumSecurities=v;}

	//Identifies whether the order should be treated as passive (will not match when entered) or aggressive (could match when entered)
	void setExecutionMode (IL3Enum::ExecMode v) { blockDataWrite_.ExecutionMode=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Boolean: flags a managed order
	void setManagedOrder (IL3Enum::BooleanNULL v) { blockDataWrite_.ManagedOrder=v;}

	//Indicates the type of short sale. Will not be used for Buy orders but Sell orders should have this tag populated for MiFID
	void setShortSaleType (IL3Enum::ShortSaleType v) { blockDataWrite_.ShortSaleType=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class ExecutionReportTradeAddendumSpreadLegMsg {
public:
	inline static const std::size_t id{550};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	[[nodiscard]] std::string_view getExecID () const { return std::string_view(&blockData_->ExecID[0], 40);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	[[nodiscard]] std::string_view getClOrdID () const { return std::string_view(&blockData_->ClOrdID[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	[[nodiscard]] std::uint64_t getOrderID () const { return blockData_->OrderID;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Unique identifier that allows linking between spread summary fill notice with leg fill notice and trade cancel messages. Trade correction of previously executed trade will assign a new value
	[[nodiscard]] std::uint64_t getSecExecID () const { return blockData_->SecExecID;}

	//Unique identifier of the fill which is being corrected
	[[nodiscard]] std::uint64_t getOrigSecondaryExecutionID () const { return blockData_->OrigSecondaryExecutionID;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Quantity of shares bought/sold on this (last) fill
	[[nodiscard]] std::uint32_t getLastQty () const { return blockData_->LastQty;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	[[nodiscard]] std::uint32_t getSideTradeID () const { return blockData_->SideTradeID;}

	//Refers back to the unique ID assigned to the original trade being corrected
	[[nodiscard]] std::uint32_t getOrigSideTradeID () const { return blockData_->OrigSideTradeID;}

	//Indicates date of trading day (expressed in local time at place of trade).
	[[nodiscard]] std::uint16_t getTradeDate () const { return blockData_->TradeDate;}

	//Identifies status of order as trade cancellation or correction
	[[nodiscard]] IL3Enum::OrdStatusTrdCxl getOrdStatus () const { return blockData_->OrdStatus;}

	//Describes the specific ExecutionRpt as trade cancellation or correction
	[[nodiscard]] IL3Enum::ExecTypTrdCxl getExecType () const { return blockData_->ExecType;}

	//Indicates if the message was initially received manually (as opposed to electronically) 
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Order side
	[[nodiscard]] IL3Enum::SideReq getSide () const { return blockData_->Side;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 40> ExecID;
		std::array<char, 20> SenderID;
		std::array<char, 20> ClOrdID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t OrderID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t SecExecID;
		std::uint64_t OrigSecondaryExecutionID {18446744073709551615UL};
		std::array<char, 5> Location;
		std::int32_t SecurityID;
		std::uint32_t LastQty;
		std::uint32_t SideTradeID;
		std::uint32_t OrigSideTradeID {4294967295UL};
		std::uint16_t TradeDate {65535UL};
		IL3Enum::OrdStatusTrdCxl OrdStatus;
		IL3Enum::ExecTypTrdCxl ExecType;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::BooleanFlag PossRetransFlag;
		IL3Enum::SideReq Side;
	};

	const BlockData *blockData_{nullptr};
};


class ExecutionReportTradeAddendumSpreadLegMsgOut: public ExecutionReportTradeAddendumSpreadLegMsg {
public:
	inline static const std::size_t blockLength {176};
	//static_assert (ExecutionReportTradeAddendumSpreadLegMsgOut::blockLength==sizeof (ExecutionReportTradeAddendumSpreadLegMsgOut::BlockData));

	ExecutionReportTradeAddendumSpreadLegMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Unique identifier of execution message as assigned by exchange. Uniqueness will be guaranteed within a single trading day or the life of a multi-day order
	void setExecID (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Unique identifier for Order as assigned by the buy-side (institution, broker, intermediary etc.). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods, should ensure uniqueness across days, for example by embedding a date within the ClOrdID field
	void setClOrdID (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for order as assigned by the exchange. Uniqueness is guaranteed within a single trading day across all instruments
	void setOrderID (std::uint64_t v) { blockDataWrite_.OrderID=v;}

	//Time the transaction represented by this ExecutionReport (35=8) occurred. Expressed as nanoseconds since epoch time
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Unique identifier that allows linking between spread summary fill notice with leg fill notice and trade cancel messages. Trade correction of previously executed trade will assign a new value
	void setSecExecID (std::uint64_t v) { blockDataWrite_.SecExecID=v;}

	//Unique identifier of the fill which is being corrected
	void setOrigSecondaryExecutionID (std::uint64_t v) { blockDataWrite_.OrigSecondaryExecutionID=v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Security ID as defined by CME. For the security ID list, see the security definition messages
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Quantity of shares bought/sold on this (last) fill
	void setLastQty (std::uint32_t v) { blockDataWrite_.LastQty=v;}

	//The unique ID assigned to the trade once it is received or matched by the exchange
	void setSideTradeID (std::uint32_t v) { blockDataWrite_.SideTradeID=v;}

	//Refers back to the unique ID assigned to the original trade being corrected
	void setOrigSideTradeID (std::uint32_t v) { blockDataWrite_.OrigSideTradeID=v;}

	//Indicates date of trading day (expressed in local time at place of trade).
	void setTradeDate (std::uint16_t v) { blockDataWrite_.TradeDate=v;}

	//Identifies status of order as trade cancellation or correction
	void setOrdStatus (IL3Enum::OrdStatusTrdCxl v) { blockDataWrite_.OrdStatus=v;}

	//Describes the specific ExecutionRpt as trade cancellation or correction
	void setExecType (IL3Enum::ExecTypTrdCxl v) { blockDataWrite_.ExecType=v;}

	//Indicates if the message was initially received manually (as opposed to electronically) 
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Order side
	void setSide (IL3Enum::SideReq v) { blockDataWrite_.Side=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class SecurityDefinitionRequestMsg {
public:
	inline static const std::size_t id{560};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for a security definition request. It is incumbent on the market participant to maintain uniqueness
	[[nodiscard]] std::uint64_t getSecurityReqID () const { return blockData_->SecurityReqID;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Identifies specific type of UDS; valid values are COMBO, COVERED and REPO
	[[nodiscard]] std::string_view getSecuritySubType () const { return std::string_view(&blockData_->SecuritySubType[0], 8);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Start date of a financing deal, i.e. the date the buyer pays the seller cash and takes control of the collateral
	[[nodiscard]] std::uint16_t getStartDate () const { return blockData_->StartDate;}

	//End date of a financing deal, i.e. the date the seller reimburses the buyer and takes back control of the collateral
	[[nodiscard]] std::uint16_t getEndDate () const { return blockData_->EndDate;}

	//Max number of substitutions allowed. The value of 0 indicates that substitutions are not allowed.
	[[nodiscard]] std::uint8_t getMaxNoOfSubstitutions () const { return blockData_->MaxNoOfSubstitutions;}

	//Represents the source repo instrument on which the new tailor made repo should be modeled on
	[[nodiscard]] std::int32_t getSourceRepoID () const { return blockData_->SourceRepoID;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SecurityReqID;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		std::uint32_t SeqNum;
		std::array<char, 20> SenderID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 8> SecuritySubType;
		std::array<char, 5> Location;
		std::uint16_t StartDate {65535UL};
		std::uint16_t EndDate {65535UL};
		std::uint8_t MaxNoOfSubstitutions {255UL};
		std::int32_t SourceRepoID {2147483647};
	};

	const BlockData *blockData_{nullptr};
};


class SecurityDefinitionRequestMsgOut: public SecurityDefinitionRequestMsg {
public:
	inline static const std::size_t blockLength {71};
	//static_assert (SecurityDefinitionRequestMsgOut::blockLength==sizeof (SecurityDefinitionRequestMsgOut::BlockData));

	SecurityDefinitionRequestMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for a security definition request. It is incumbent on the market participant to maintain uniqueness
	void setSecurityReqID (std::uint64_t v) { blockDataWrite_.SecurityReqID=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Identifies specific type of UDS; valid values are COMBO, COVERED and REPO
	void setSecuritySubType (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Start date of a financing deal, i.e. the date the buyer pays the seller cash and takes control of the collateral
	void setStartDate (std::uint16_t v) { blockDataWrite_.StartDate=v;}

	//End date of a financing deal, i.e. the date the seller reimburses the buyer and takes back control of the collateral
	void setEndDate (std::uint16_t v) { blockDataWrite_.EndDate=v;}

	//Max number of substitutions allowed. The value of 0 indicates that substitutions are not allowed.
	void setMaxNoOfSubstitutions (std::uint8_t v) { blockDataWrite_.MaxNoOfSubstitutions=v;}

	//Represents the source repo instrument on which the new tailor made repo should be modeled on
	void setSourceRepoID (std::int32_t v) { blockDataWrite_.SourceRepoID=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class SecurityDefinitionResponseMsg {
public:
	inline static const std::size_t id{561};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details. Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Long name of the instrument for TM Repo
	[[nodiscard]] std::string_view getFinancialInstrumentFullName () const { return std::string_view(&blockData_->FinancialInstrumentFullName[0], 35);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//Instrument Short Name for TM Repo 
	[[nodiscard]] std::string_view getSymbol () const { return std::string_view(&blockData_->Symbol[0], 20);}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Unique identifier for a security definition request
	[[nodiscard]] std::uint64_t getSecurityReqID () const { return blockData_->SecurityReqID;}

	//Unique ID of a SecurityDefinition message
	[[nodiscard]] std::uint64_t getSecurityResponseID () const { return blockData_->SecurityResponseID;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Security Group Code.  This tag was previously used as Product Code. An exchange specific code assigned to a group of related securities, which are concurrently affected by market events. 
	[[nodiscard]] std::string_view getSecurityGroup () const { return std::string_view(&blockData_->SecurityGroup[0], 6);}

	//Indicates type of security
	[[nodiscard]] std::string_view getSecurityType () const { return std::string_view(&blockData_->SecurityType[0], 6);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Unique instrument ID 
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Identifies the currency for the price
	[[nodiscard]] std::string_view getCurrency () const { return std::string_view(&blockData_->Currency[0], 3);}

	//Not being used currently
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Start date of a financing deal, i.e. the date the buyer pays the seller cash and takes control of the collateral
	[[nodiscard]] std::uint16_t getStartDate () const { return blockData_->StartDate;}

	//nd date of a financing deal, i.e. the date the seller reimburses the buyer and takes back control of the collateral
	[[nodiscard]] std::uint16_t getEndDate () const { return blockData_->EndDate;}

	//Max number of substitutions allowed. The value of 0 indicates that substitutions are not allowed.
	[[nodiscard]] std::uint8_t getMaxNoOfSubstitutions () const { return blockData_->MaxNoOfSubstitutions;}

	//Represents the source repo instrument on which the new tailor made repo should be modeled on
	[[nodiscard]] std::int32_t getSourceRepoID () const { return blockData_->SourceRepoID;}

	//Represents the term code
	[[nodiscard]] std::string_view getTerminationType () const { return std::string_view(&blockData_->TerminationType[0], 8);}

	//Type of security definition message response. 
	[[nodiscard]] IL3Enum::SecRspTyp getSecurityResponseType () const { return blockData_->SecurityResponseType;}

	//For tag 827-ExpirationCycle=2, instrument expires as indicated in market data Security Definition (tag 35-MsgType=d) repeating block:  Tag 865-EventType=7 (Last Eligible Trade Date) Tag 1145-EventTime
	[[nodiscard]] IL3Enum::ExpCycle getExpirationCycle () const { return blockData_->ExpirationCycle;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Boolean flag (0/1) to automatically send a quote request message following the security definition (35=d) message.
	[[nodiscard]] IL3Enum::BooleanFlag getAutoQuoteRequest () const { return blockData_->AutoQuoteRequest;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 35> FinancialInstrumentFullName;
		std::array<char, 20> SenderID;
		std::array<char, 20> Symbol;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t SecurityReqID;
		std::uint64_t SecurityResponseID;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 6> SecurityGroup;
		std::array<char, 6> SecurityType;
		std::array<char, 5> Location;
		std::int32_t SecurityID {2147483647};
		std::array<char, 3> Currency;
		std::uint16_t DelayDuration {65535UL};
		std::uint16_t StartDate {65535UL};
		std::uint16_t EndDate {65535UL};
		std::uint8_t MaxNoOfSubstitutions {255UL};
		std::int32_t SourceRepoID {2147483647};
		std::array<char, 8> TerminationType;
		IL3Enum::SecRspTyp SecurityResponseType;
		IL3Enum::ExpCycle ExpirationCycle {IL3Enum::ExpCycle::Null};
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::BooleanFlag AutoQuoteRequest;
		IL3Enum::BooleanFlag PossRetransFlag;
	};

	const BlockData *blockData_{nullptr};
};


class SecurityDefinitionResponseMsgOut: public SecurityDefinitionResponseMsg {
public:
	inline static const std::size_t blockLength {429};
	//static_assert (SecurityDefinitionResponseMsgOut::blockLength==sizeof (SecurityDefinitionResponseMsgOut::BlockData));

	SecurityDefinitionResponseMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details. Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Long name of the instrument for TM Repo
	void setFinancialInstrumentFullName (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//Instrument Short Name for TM Repo 
	void setSymbol (std::string_view v) { (void) v;}

	//Refers to the ID of the related PartyDetailsDefinitionRequest message which will logically be tied to this message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Unique identifier for a security definition request
	void setSecurityReqID (std::uint64_t v) { blockDataWrite_.SecurityReqID=v;}

	//Unique ID of a SecurityDefinition message
	void setSecurityResponseID (std::uint64_t v) { blockDataWrite_.SecurityResponseID=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Security Group Code.  This tag was previously used as Product Code. An exchange specific code assigned to a group of related securities, which are concurrently affected by market events. 
	void setSecurityGroup (std::string_view v) { (void) v;}

	//Indicates type of security
	void setSecurityType (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Unique instrument ID 
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Identifies the currency for the price
	void setCurrency (std::string_view v) { (void) v;}

	//Not being used currently
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Start date of a financing deal, i.e. the date the buyer pays the seller cash and takes control of the collateral
	void setStartDate (std::uint16_t v) { blockDataWrite_.StartDate=v;}

	//nd date of a financing deal, i.e. the date the seller reimburses the buyer and takes back control of the collateral
	void setEndDate (std::uint16_t v) { blockDataWrite_.EndDate=v;}

	//Max number of substitutions allowed. The value of 0 indicates that substitutions are not allowed.
	void setMaxNoOfSubstitutions (std::uint8_t v) { blockDataWrite_.MaxNoOfSubstitutions=v;}

	//Represents the source repo instrument on which the new tailor made repo should be modeled on
	void setSourceRepoID (std::int32_t v) { blockDataWrite_.SourceRepoID=v;}

	//Represents the term code
	void setTerminationType (std::string_view v) { (void) v;}

	//Type of security definition message response. 
	void setSecurityResponseType (IL3Enum::SecRspTyp v) { blockDataWrite_.SecurityResponseType=v;}

	//For tag 827-ExpirationCycle=2, instrument expires as indicated in market data Security Definition (tag 35-MsgType=d) repeating block:  Tag 865-EventType=7 (Last Eligible Trade Date) Tag 1145-EventTime
	void setExpirationCycle (IL3Enum::ExpCycle v) { blockDataWrite_.ExpirationCycle=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Boolean flag (0/1) to automatically send a quote request message following the security definition (35=d) message.
	void setAutoQuoteRequest (IL3Enum::BooleanFlag v) { blockDataWrite_.AutoQuoteRequest=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class OrderMassActionReportMsg {
public:
	inline static const std::size_t id{562};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Time of execution/order creation; expressed in UTC.
	[[nodiscard]] std::uint64_t getTransactTime () const { return blockData_->TransactTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//OrderRequestID used to identify an OrderMassActionRequest and echo the value on the corresponding OrderMassActionReport
	[[nodiscard]] std::uint64_t getOrderRequestID () const { return blockData_->OrderRequestID;}

	//Unique ID of Order Mass Action Report as assigned by CME. If fragmented then all messages must have the same value.
	[[nodiscard]] std::uint64_t getMassActionReportID () const { return blockData_->MassActionReportID;}

	//Specifies the Product Group for which working orders should be cancelled. Conditionally present if MassActionScope=Product Group (Tag1374=10).
	[[nodiscard]] std::string_view getSecurityGroup () const { return std::string_view(&blockData_->SecurityGroup[0], 6);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Conditionally present if MassActionScope=Instrument (Tag 1374=1)
	[[nodiscard]] std::int32_t getSecurityID () const { return blockData_->SecurityID;}

	//Not being used currently
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Specifies the action taken by CME when it received the Order Mass Action Request.
	[[nodiscard]] IL3Enum::MassActionResponse getMassActionResponse () const { return blockData_->MassActionResponse;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Specifies the scope of the action  
	[[nodiscard]] IL3Enum::MassActionScope getMassActionScope () const { return blockData_->MassActionScope;}

	//Total number of orders affected by the Order Mass  Action Request. Will be returned as zero for rejects or if request is accepted but no orders could be cancelled. If fragmented then this is the sum of NoAffectedOrders across all messages with the same MassActionReportID. Otherwise will have same value as NoAffectedOrders when one or more orders is cancelled.
	[[nodiscard]] std::uint32_t getTotalAffectedOrders () const { return blockData_->TotalAffectedOrders;}

	//Indicates whether the message is the last message in a sequence of messages to support fragmentation
	[[nodiscard]] IL3Enum::BooleanFlag getLastFragment () const { return blockData_->LastFragment;}

	//Reason Order Mass Action Request was rejected. Required if Mass Action Response=0.
	[[nodiscard]] std::uint8_t getMassActionRejectReason () const { return blockData_->MassActionRejectReason;}

	//Specifies the market segment (physical match engine partition) for which working orders should be cancelled. Conditionally present if MassActionScope=Market Segment (Tag 1374=9)
	[[nodiscard]] std::uint8_t getMarketSegmentID () const { return blockData_->MarketSegmentID;}

	//If present specifies the scope of the OrderMassActionRequest within the context of Session and Firm. If absent then all orders belonging to Session and Firm combination will be cancelled for specified MassActionScope
	[[nodiscard]] IL3Enum::MassCxlReqTyp getMassCancelRequestType () const { return blockData_->MassCancelRequestType;}

	//f provided then only orders belonging to one side will be cancelled. If absent then orders belonging to both sides will be cancelled
	[[nodiscard]] IL3Enum::SideNULL getSide () const { return blockData_->Side;}

	//If provided then only orders of this type will be cancelled. If absent then all order types will be cancelled
	[[nodiscard]] IL3Enum::MassActionOrdTyp getOrdType () const { return blockData_->OrdType;}

	//If provided then only orders with this qualifier will be cancelled. If absent then all Day & GT orders will be cancelled
	[[nodiscard]] IL3Enum::MassCancelTIF getTimeInForce () const { return blockData_->TimeInForce;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 20> SenderID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t TransactTime;
		std::uint64_t SendingTimeEpoch;
		std::uint64_t OrderRequestID;
		std::uint64_t MassActionReportID;
		std::array<char, 6> SecurityGroup;
		std::array<char, 5> Location;
		std::int32_t SecurityID {2147483647};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::MassActionResponse MassActionResponse;
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::MassActionScope MassActionScope;
		std::uint32_t TotalAffectedOrders;
		IL3Enum::BooleanFlag LastFragment;
		std::uint8_t MassActionRejectReason {255UL};
		std::uint8_t MarketSegmentID {255UL};
		IL3Enum::MassCxlReqTyp MassCancelRequestType {IL3Enum::MassCxlReqTyp::Null};
		IL3Enum::SideNULL Side {IL3Enum::SideNULL::Null};
		IL3Enum::MassActionOrdTyp OrdType {IL3Enum::MassActionOrdTyp::Null};
		IL3Enum::MassCancelTIF TimeInForce {IL3Enum::MassCancelTIF::Null};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanFlag PossRetransFlag;
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class OrderMassActionReportMsgOut: public OrderMassActionReportMsg {
public:
	inline static const std::size_t blockLength {114};
	//static_assert (OrderMassActionReportMsgOut::blockLength==sizeof (OrderMassActionReportMsgOut::BlockData));

	OrderMassActionReportMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Time of execution/order creation; expressed in UTC.
	void setTransactTime (std::uint64_t v) { blockDataWrite_.TransactTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//OrderRequestID used to identify an OrderMassActionRequest and echo the value on the corresponding OrderMassActionReport
	void setOrderRequestID (std::uint64_t v) { blockDataWrite_.OrderRequestID=v;}

	//Unique ID of Order Mass Action Report as assigned by CME. If fragmented then all messages must have the same value.
	void setMassActionReportID (std::uint64_t v) { blockDataWrite_.MassActionReportID=v;}

	//Specifies the Product Group for which working orders should be cancelled. Conditionally present if MassActionScope=Product Group (Tag1374=10).
	void setSecurityGroup (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Conditionally present if MassActionScope=Instrument (Tag 1374=1)
	void setSecurityID (std::int32_t v) { blockDataWrite_.SecurityID=v;}

	//Not being used currently
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Specifies the action taken by CME when it received the Order Mass Action Request.
	void setMassActionResponse (IL3Enum::MassActionResponse v) { blockDataWrite_.MassActionResponse=v;}

	//Indicates if the order was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Specifies the scope of the action  
	void setMassActionScope (IL3Enum::MassActionScope v) { blockDataWrite_.MassActionScope=v;}

	//Total number of orders affected by the Order Mass  Action Request. Will be returned as zero for rejects or if request is accepted but no orders could be cancelled. If fragmented then this is the sum of NoAffectedOrders across all messages with the same MassActionReportID. Otherwise will have same value as NoAffectedOrders when one or more orders is cancelled.
	void setTotalAffectedOrders (std::uint32_t v) { blockDataWrite_.TotalAffectedOrders=v;}

	//Indicates whether the message is the last message in a sequence of messages to support fragmentation
	void setLastFragment (IL3Enum::BooleanFlag v) { blockDataWrite_.LastFragment=v;}

	//Reason Order Mass Action Request was rejected. Required if Mass Action Response=0.
	void setMassActionRejectReason (std::uint8_t v) { blockDataWrite_.MassActionRejectReason=v;}

	//Specifies the market segment (physical match engine partition) for which working orders should be cancelled. Conditionally present if MassActionScope=Market Segment (Tag 1374=9)
	void setMarketSegmentID (std::uint8_t v) { blockDataWrite_.MarketSegmentID=v;}

	//If present specifies the scope of the OrderMassActionRequest within the context of Session and Firm. If absent then all orders belonging to Session and Firm combination will be cancelled for specified MassActionScope
	void setMassCancelRequestType (IL3Enum::MassCxlReqTyp v) { blockDataWrite_.MassCancelRequestType=v;}

	//f provided then only orders belonging to one side will be cancelled. If absent then orders belonging to both sides will be cancelled
	void setSide (IL3Enum::SideNULL v) { blockDataWrite_.Side=v;}

	//If provided then only orders of this type will be cancelled. If absent then all order types will be cancelled
	void setOrdType (IL3Enum::MassActionOrdTyp v) { blockDataWrite_.OrdType=v;}

	//If provided then only orders with this qualifier will be cancelled. If absent then all Day & GT orders will be cancelled
	void setTimeInForce (IL3Enum::MassCancelTIF v) { blockDataWrite_.TimeInForce=v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

class QuoteCancelAckMsg {
public:
	inline static const std::size_t id{563};

	//Sequence number as assigned to message
	[[nodiscard]] std::uint32_t getSeqNum () const { return blockData_->SeqNum;}

	//Matches Establish.UUID used to establish the connection
	[[nodiscard]] std::uint64_t getUUID () const { return blockData_->UUID;}

	//Reject reason details. Will be used only for descriptive rejects
	[[nodiscard]] std::string_view getText () const { return std::string_view(&blockData_->Text[0], 256);}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	[[nodiscard]] std::string_view getSenderID () const { return std::string_view(&blockData_->SenderID[0], 20);}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	[[nodiscard]] std::uint64_t getPartyDetailsListReqID () const { return blockData_->PartyDetailsListReqID;}

	//Information carried on a response to convey the time (UTC) when the request was received by the MSGW application. UTC timestamps are sent in number of nanoseconds since the UNIX epoch with microsecond precision
	[[nodiscard]] std::uint64_t getRequestTime () const { return blockData_->RequestTime;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	[[nodiscard]] std::uint64_t getSendingTimeEpoch () const { return blockData_->SendingTimeEpoch;}

	//Instrument Group cancelled for a Quote Cancel acknowledgement.
	[[nodiscard]] std::string_view getCancelledSymbol () const { return std::string_view(&blockData_->CancelledSymbol[0], 6);}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	[[nodiscard]] std::string_view getLocation () const { return std::string_view(&blockData_->Location[0], 5);}

	//Unique identifier for quote cancel message
	[[nodiscard]] std::uint32_t getQuoteID () const { return blockData_->QuoteID;}

	//Contains reason (error code) the corresponding QuoteCancel message has been rejected
	[[nodiscard]] std::uint16_t getQuoteRejectReason () const { return blockData_->QuoteRejectReason;}

	//Not being currently used
	[[nodiscard]] std::uint16_t getDelayDuration () const { return blockData_->DelayDuration;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	[[nodiscard]] IL3Enum::ManualOrdIndReq getManualOrderIndicator () const { return blockData_->ManualOrderIndicator;}

	//Identifies the type of Quote Cancel. A working quote can be cancelled by providing either it's instrument, quote set, product group, or by cancelling all
	[[nodiscard]] IL3Enum::QuoteCxlStatus getQuoteStatus () const { return blockData_->QuoteStatus;}

	//Number of quotes successfully cancelled (if in response to a Quote Cancel message)
	[[nodiscard]] std::uint32_t getNoProcessedEntries () const { return blockData_->NoProcessedEntries;}

	//This tag is sent and set to '1' on the quote cancel acknowledgment which is sent after Market Maker protection is triggered and all resting quotes are cancelled for that particular group (297=3)
	[[nodiscard]] IL3Enum::BooleanFlag getMMProtectionReset () const { return blockData_->MMProtectionReset;}

	//Type of quote cancel generated by CME -- returned only for unsolicited quote cancels
	[[nodiscard]] std::string_view getUnsolicitedCancelType () const { return std::string_view(&blockData_->UnsolicitedCancelType[0], 1);}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	[[nodiscard]] IL3Enum::SplitMsg getSplitMsg () const { return blockData_->SplitMsg;}

	//Total number of quotes for the quote set across all messages. Will be populated only for enumerated rejects for Cancel By Instrument
	[[nodiscard]] std::uint8_t getTotNoQuoteEntries () const { return blockData_->TotNoQuoteEntries;}

	//Represents the market making MiFID obligation reporting
	[[nodiscard]] IL3Enum::BooleanNULL getLiquidityFlag () const { return blockData_->LiquidityFlag;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	[[nodiscard]] IL3Enum::BooleanFlag getPossRetransFlag () const { return blockData_->PossRetransFlag;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	[[nodiscard]] std::uint64_t getDelayToTime () const { return blockData_->DelayToTime;}


	void readFromBuffer(MessageBuffer &msgBuffer);
protected:
	struct __attribute__ ((packed))  BlockData {
		std::uint32_t SeqNum;
		std::uint64_t UUID;
		std::array<char, 256> Text;
		std::array<char, 20> SenderID;
		std::uint64_t PartyDetailsListReqID;
		std::uint64_t RequestTime;
		std::uint64_t SendingTimeEpoch;
		std::array<char, 6> CancelledSymbol;
		std::array<char, 5> Location;
		std::uint32_t QuoteID;
		std::uint16_t QuoteRejectReason {65535UL};
		std::uint16_t DelayDuration {65535UL};
		IL3Enum::ManualOrdIndReq ManualOrderIndicator;
		IL3Enum::QuoteCxlStatus QuoteStatus;
		std::uint32_t NoProcessedEntries;
		IL3Enum::BooleanFlag MMProtectionReset;
		std::array<char, 1> UnsolicitedCancelType {0};
		IL3Enum::SplitMsg SplitMsg {IL3Enum::SplitMsg::Null};
		std::uint8_t TotNoQuoteEntries {255UL};
		IL3Enum::BooleanNULL LiquidityFlag {IL3Enum::BooleanNULL::Null};
		IL3Enum::BooleanFlag PossRetransFlag;
		std::uint64_t DelayToTime {18446744073709551615UL};
	};

	const BlockData *blockData_{nullptr};
};


class QuoteCancelAckMsgOut: public QuoteCancelAckMsg {
public:
	inline static const std::size_t blockLength {351};
	//static_assert (QuoteCancelAckMsgOut::blockLength==sizeof (QuoteCancelAckMsgOut::BlockData));

	QuoteCancelAckMsgOut () {
		blockData_ = &blockDataWrite_;
	};

	//Sequence number as assigned to message
	void setSeqNum (std::uint32_t v) { blockDataWrite_.SeqNum=v;}

	//Matches Establish.UUID used to establish the connection
	void setUUID (std::uint64_t v) { blockDataWrite_.UUID=v;}

	//Reject reason details. Will be used only for descriptive rejects
	void setText (std::string_view v) { (void) v;}

	//Operator ID. Should be unique per Firm ID. Assigned value used to identify specific message originator. Represents last individual or team in charge of the system which modifies the order before submission to the Globex platform, or if not modified from initiator (party role=118), last individual or team in charge of the system, which submit the order to the Globex platform
	void setSenderID (std::string_view v) { (void) v;}

	//The unique identifier of the PartyDetailsDefinitionRequestAck attached to this message; pancake flip of what was submitted on inbound message
	void setPartyDetailsListReqID (std::uint64_t v) { blockDataWrite_.PartyDetailsListReqID=v;}

	//Information carried on a response to convey the time (UTC) when the request was received by the MSGW application. UTC timestamps are sent in number of nanoseconds since the UNIX epoch with microsecond precision
	void setRequestTime (std::uint64_t v) { blockDataWrite_.RequestTime=v;}

	//Time when the message is sent. 64-bit integer expressing the number of nano seconds since midnight January 1, 1970.
	void setSendingTimeEpoch (std::uint64_t v) { blockDataWrite_.SendingTimeEpoch=v;}

	//Instrument Group cancelled for a Quote Cancel acknowledgement.
	void setCancelledSymbol (std::string_view v) { (void) v;}

	//Text describing sender's location (i.e. geopraphic location and/or desk)
	void setLocation (std::string_view v) { (void) v;}

	//Unique identifier for quote cancel message
	void setQuoteID (std::uint32_t v) { blockDataWrite_.QuoteID=v;}

	//Contains reason (error code) the corresponding QuoteCancel message has been rejected
	void setQuoteRejectReason (std::uint16_t v) { blockDataWrite_.QuoteRejectReason=v;}

	//Not being currently used
	void setDelayDuration (std::uint16_t v) { blockDataWrite_.DelayDuration=v;}

	//Indicates if the message was initially received manually (as opposed to electronically)
	void setManualOrderIndicator (IL3Enum::ManualOrdIndReq v) { blockDataWrite_.ManualOrderIndicator=v;}

	//Identifies the type of Quote Cancel. A working quote can be cancelled by providing either it's instrument, quote set, product group, or by cancelling all
	void setQuoteStatus (IL3Enum::QuoteCxlStatus v) { blockDataWrite_.QuoteStatus=v;}

	//Number of quotes successfully cancelled (if in response to a Quote Cancel message)
	void setNoProcessedEntries (std::uint32_t v) { blockDataWrite_.NoProcessedEntries=v;}

	//This tag is sent and set to '1' on the quote cancel acknowledgment which is sent after Market Maker protection is triggered and all resting quotes are cancelled for that particular group (297=3)
	void setMMProtectionReset (IL3Enum::BooleanFlag v) { blockDataWrite_.MMProtectionReset=v;}

	//Type of quote cancel generated by CME -- returned only for unsolicited quote cancels
	void setUnsolicitedCancelType (std::string_view v) { (void) v;}

	//Indicates whether a message was delayed as a result of being split among multiple packets (0) or if a message was delayed as a result of TCP re-transmission (1) or if a complete message was delayed due to a previously submitted split or out of order message (2). If absent then the message was not delayed and was neither split nor received out of order
	void setSplitMsg (IL3Enum::SplitMsg v) { blockDataWrite_.SplitMsg=v;}

	//Total number of quotes for the quote set across all messages. Will be populated only for enumerated rejects for Cancel By Instrument
	void setTotNoQuoteEntries (std::uint8_t v) { blockDataWrite_.TotNoQuoteEntries=v;}

	//Represents the market making MiFID obligation reporting
	void setLiquidityFlag (IL3Enum::BooleanNULL v) { blockDataWrite_.LiquidityFlag=v;}

	//Flags message as possible retransmission. This will convey whether a message is an original transmission or duplicate in response to RetransmissionRequest. This will become pertinent when original messages get interleaved with Retransmission responses
	void setPossRetransFlag (IL3Enum::BooleanFlag v) { blockDataWrite_.PossRetransFlag=v;}

	//Indicates the amount of time that a message was delayed as a result of being split (9553=0) or as a result of being out of order due to TCP retransmission (9553=1) or as a result of being queued behind a split message (9553=2). Represented as number of nanoseconds in unix epoch format (since Jan 1, 1970). Subtracting this number from FIFO time will represent original received time of delayed message
	void setDelayToTime (std::uint64_t v) { blockDataWrite_.DelayToTime=v;}

	void writeToBuffer(MessageBuffer &msgBuffer);
protected:
	BlockData blockDataWrite_;

};

} //end of namespace IL3Msg
#endif //CMESIMULATOR_ILINK3_MSGS_GEN_H
